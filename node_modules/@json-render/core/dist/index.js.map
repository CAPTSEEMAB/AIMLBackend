{"version":3,"sources":["../src/index.ts","../src/types.ts","../src/visibility.ts","../src/props.ts","../src/actions.ts","../src/validation.ts","../src/spec-validator.ts","../src/schema.ts","../src/prompt.ts"],"sourcesContent":["// Types\nexport type {\n  DynamicValue,\n  DynamicString,\n  DynamicNumber,\n  DynamicBoolean,\n  UIElement,\n  FlatElement,\n  Spec,\n  VisibilityCondition,\n  StateCondition,\n  ItemCondition,\n  IndexCondition,\n  SingleCondition,\n  AndCondition,\n  OrCondition,\n  StateModel,\n  ComponentSchema,\n  ValidationMode,\n  PatchOp,\n  JsonPatch,\n  // SpecStream types\n  SpecStreamLine,\n  SpecStreamCompiler,\n  // Mixed stream types (chat + GenUI)\n  MixedStreamCallbacks,\n  MixedStreamParser,\n  // AI SDK stream transform\n  StreamChunk,\n  SpecDataPart,\n} from \"./types\";\n\nexport {\n  DynamicValueSchema,\n  DynamicStringSchema,\n  DynamicNumberSchema,\n  DynamicBooleanSchema,\n  resolveDynamicValue,\n  getByPath,\n  setByPath,\n  addByPath,\n  removeByPath,\n  findFormValue,\n  // SpecStream - streaming format for building specs (RFC 6902)\n  parseSpecStreamLine,\n  applySpecStreamPatch,\n  applySpecPatch,\n  nestedToFlat,\n  compileSpecStream,\n  createSpecStreamCompiler,\n  // Mixed stream parser (chat + GenUI)\n  createMixedStreamParser,\n  // AI SDK stream transform\n  createJsonRenderTransform,\n  pipeJsonRender,\n  SPEC_DATA_PART,\n  SPEC_DATA_PART_TYPE,\n} from \"./types\";\n\n// Visibility\nexport type { VisibilityContext } from \"./visibility\";\n\nexport {\n  VisibilityConditionSchema,\n  evaluateVisibility,\n  visibility,\n} from \"./visibility\";\n\n// Prop Expressions\nexport type { PropExpression, PropResolutionContext } from \"./props\";\n\nexport {\n  resolvePropValue,\n  resolveElementProps,\n  resolveBindings,\n  resolveActionParam,\n} from \"./props\";\n\n// Actions\nexport type {\n  ActionBinding,\n  /** @deprecated Use ActionBinding instead */\n  Action,\n  ActionConfirm,\n  ActionOnSuccess,\n  ActionOnError,\n  ActionHandler,\n  ActionDefinition,\n  ResolvedAction,\n  ActionExecutionContext,\n} from \"./actions\";\n\nexport {\n  ActionBindingSchema,\n  /** @deprecated Use ActionBindingSchema instead */\n  ActionSchema,\n  ActionConfirmSchema,\n  ActionOnSuccessSchema,\n  ActionOnErrorSchema,\n  resolveAction,\n  executeAction,\n  interpolateString,\n  actionBinding,\n  /** @deprecated Use actionBinding instead */\n  action,\n} from \"./actions\";\n\n// Validation\nexport type {\n  ValidationCheck,\n  ValidationConfig,\n  ValidationFunction,\n  ValidationFunctionDefinition,\n  ValidationCheckResult,\n  ValidationResult,\n  ValidationContext,\n} from \"./validation\";\n\nexport {\n  ValidationCheckSchema,\n  ValidationConfigSchema,\n  builtInValidationFunctions,\n  runValidationCheck,\n  runValidation,\n  check,\n} from \"./validation\";\n\n// Spec Structural Validation\nexport type {\n  SpecIssueSeverity,\n  SpecIssue,\n  SpecValidationIssues,\n  ValidateSpecOptions,\n} from \"./spec-validator\";\n\nexport { validateSpec, autoFixSpec, formatSpecIssues } from \"./spec-validator\";\n\n// Schema — defines the grammar (how specs and catalogs are structured)\nexport type {\n  SchemaBuilder,\n  SchemaType,\n  SchemaDefinition,\n  Schema,\n  PromptTemplate,\n  SchemaOptions,\n} from \"./schema\";\n\nexport { defineSchema } from \"./schema\";\n\n// Catalog — defines the vocabulary (what components and actions are available)\nexport type {\n  Catalog,\n  PromptOptions,\n  PromptContext,\n  SpecValidationResult,\n  InferCatalogInput,\n  InferSpec,\n  InferCatalogComponents,\n  InferCatalogActions,\n  InferComponentProps,\n  InferActionParams,\n} from \"./schema\";\n\nexport { defineCatalog } from \"./schema\";\n\n// User Prompt Builder\nexport type { UserPromptOptions } from \"./prompt\";\n\nexport { buildUserPrompt } from \"./prompt\";\n","import { z } from \"zod\";\nimport type { ActionBinding } from \"./actions\";\n\n/**\n * Dynamic value - can be a literal or a `{ $state }` reference to the state model.\n *\n * Used in action params and validation args where values can either be\n * hardcoded or resolved from state at runtime.\n */\nexport type DynamicValue<T = unknown> = T | { $state: string };\n\n/**\n * Dynamic string value\n */\nexport type DynamicString = DynamicValue<string>;\n\n/**\n * Dynamic number value\n */\nexport type DynamicNumber = DynamicValue<number>;\n\n/**\n * Dynamic boolean value\n */\nexport type DynamicBoolean = DynamicValue<boolean>;\n\n/**\n * Zod schema for dynamic values\n */\nexport const DynamicValueSchema = z.union([\n  z.string(),\n  z.number(),\n  z.boolean(),\n  z.null(),\n  z.object({ $state: z.string() }),\n]);\n\nexport const DynamicStringSchema = z.union([\n  z.string(),\n  z.object({ $state: z.string() }),\n]);\n\nexport const DynamicNumberSchema = z.union([\n  z.number(),\n  z.object({ $state: z.string() }),\n]);\n\nexport const DynamicBooleanSchema = z.union([\n  z.boolean(),\n  z.object({ $state: z.string() }),\n]);\n\n/**\n * Base UI element structure for v2\n */\nexport interface UIElement<\n  T extends string = string,\n  P = Record<string, unknown>,\n> {\n  /** Component type from the catalog */\n  type: T;\n  /** Component props */\n  props: P;\n  /** Child element keys (flat structure) */\n  children?: string[];\n  /** Visibility condition */\n  visible?: VisibilityCondition;\n  /** Event bindings — maps event names to action bindings */\n  on?: Record<string, ActionBinding | ActionBinding[]>;\n  /** Repeat children once per item in a state array */\n  repeat?: { statePath: string; key?: string };\n}\n\n/**\n * Element with key and parentKey for use with flatToTree.\n * When elements are in an array (not a keyed map), key and parentKey\n * are needed to establish identity and parent-child relationships.\n */\nexport interface FlatElement<\n  T extends string = string,\n  P = Record<string, unknown>,\n> extends UIElement<T, P> {\n  /** Unique key identifying this element */\n  key: string;\n  /** Parent element key (null for root) */\n  parentKey?: string | null;\n}\n\n/**\n * Shared comparison operators for visibility conditions.\n *\n * Use at most ONE comparison operator per condition. If multiple are\n * provided, only the first matching one is evaluated (precedence:\n * eq > neq > gt > gte > lt > lte). With no operator, truthiness is checked.\n *\n * `not` inverts the final result of whichever operator (or truthiness\n * check) is used.\n */\ntype ComparisonOperators = {\n  eq?: unknown;\n  neq?: unknown;\n  gt?: number | { $state: string };\n  gte?: number | { $state: string };\n  lt?: number | { $state: string };\n  lte?: number | { $state: string };\n  not?: true;\n};\n\n/**\n * A single state-based condition.\n * Resolves `$state` to a value from the state model, then applies the operator.\n * Without an operator, checks truthiness.\n *\n * When `not` is `true`, the result of the entire condition is inverted.\n * For example `{ $state: \"/count\", gt: 5, not: true }` means \"NOT greater than 5\".\n */\nexport type StateCondition = { $state: string } & ComparisonOperators;\n\n/**\n * A condition that resolves `$item` to a field on the current repeat item.\n * Only meaningful inside a `repeat` scope.\n *\n * Use `\"\"` to reference the whole item, or `\"field\"` for a specific field.\n */\nexport type ItemCondition = { $item: string } & ComparisonOperators;\n\n/**\n * A condition that resolves `$index` to the current repeat array index.\n * Only meaningful inside a `repeat` scope.\n */\nexport type IndexCondition = { $index: true } & ComparisonOperators;\n\n/** A single visibility condition (state, item, or index). */\nexport type SingleCondition = StateCondition | ItemCondition | IndexCondition;\n\n/**\n * AND wrapper — all child conditions must be true.\n * This is the explicit form of the implicit array AND (`SingleCondition[]`).\n * Unlike the implicit form, `$and` supports nested `$or` and `$and` conditions.\n */\nexport type AndCondition = { $and: VisibilityCondition[] };\n\n/**\n * OR wrapper — at least one child condition must be true.\n */\nexport type OrCondition = { $or: VisibilityCondition[] };\n\n/**\n * Visibility condition types.\n * - `boolean` — always/never\n * - `SingleCondition` — single condition (`$state`, `$item`, or `$index`)\n * - `SingleCondition[]` — implicit AND (all must be true)\n * - `AndCondition` — `{ $and: [...] }`, explicit AND (all must be true)\n * - `OrCondition` — `{ $or: [...] }`, at least one must be true\n */\nexport type VisibilityCondition =\n  | boolean\n  | SingleCondition\n  | SingleCondition[]\n  | AndCondition\n  | OrCondition;\n\n/**\n * Flat UI tree structure (optimized for LLM generation)\n */\nexport interface Spec {\n  /** Root element key */\n  root: string;\n  /** Flat map of elements by key */\n  elements: Record<string, UIElement>;\n  /** Optional initial state to seed the state model.\n   *  Components using statePath will read from / write to this state. */\n  state?: Record<string, unknown>;\n}\n\n/**\n * State model type\n */\nexport type StateModel = Record<string, unknown>;\n\n/**\n * Component schema definition using Zod\n */\nexport type ComponentSchema = z.ZodType<Record<string, unknown>>;\n\n/**\n * Validation mode for catalog validation\n */\nexport type ValidationMode = \"strict\" | \"warn\" | \"ignore\";\n\n/**\n * JSON patch operation types (RFC 6902)\n */\nexport type PatchOp = \"add\" | \"remove\" | \"replace\" | \"move\" | \"copy\" | \"test\";\n\n/**\n * JSON patch operation (RFC 6902)\n */\nexport interface JsonPatch {\n  op: PatchOp;\n  path: string;\n  /** Required for add, replace, test */\n  value?: unknown;\n  /** Required for move, copy (source location) */\n  from?: string;\n}\n\n/**\n * Resolve a dynamic value against a state model\n */\nexport function resolveDynamicValue<T>(\n  value: DynamicValue<T>,\n  stateModel: StateModel,\n): T | undefined {\n  if (value === null || value === undefined) {\n    return undefined;\n  }\n\n  if (typeof value === \"object\" && \"$state\" in value) {\n    return getByPath(stateModel, (value as { $state: string }).$state) as\n      | T\n      | undefined;\n  }\n\n  return value as T;\n}\n\n/**\n * Unescape a JSON Pointer token per RFC 6901 Section 4.\n * ~1 is decoded to / and ~0 is decoded to ~ (order matters).\n */\nfunction unescapeJsonPointer(token: string): string {\n  return token.replace(/~1/g, \"/\").replace(/~0/g, \"~\");\n}\n\n/**\n * Parse a JSON Pointer path into unescaped segments.\n */\nfunction parseJsonPointer(path: string): string[] {\n  const raw = path.startsWith(\"/\") ? path.slice(1).split(\"/\") : path.split(\"/\");\n  return raw.map(unescapeJsonPointer);\n}\n\n/**\n * Get a value from an object by JSON Pointer path (RFC 6901)\n */\nexport function getByPath(obj: unknown, path: string): unknown {\n  if (!path || path === \"/\") {\n    return obj;\n  }\n\n  const segments = parseJsonPointer(path);\n\n  let current: unknown = obj;\n\n  for (const segment of segments) {\n    if (current === null || current === undefined) {\n      return undefined;\n    }\n\n    if (Array.isArray(current)) {\n      const index = parseInt(segment, 10);\n      current = current[index];\n    } else if (typeof current === \"object\") {\n      current = (current as Record<string, unknown>)[segment];\n    } else {\n      return undefined;\n    }\n  }\n\n  return current;\n}\n\n/**\n * Check if a string is a numeric index\n */\nfunction isNumericIndex(str: string): boolean {\n  return /^\\d+$/.test(str);\n}\n\n/**\n * Set a value in an object by JSON Pointer path (RFC 6901).\n * Automatically creates arrays when the path segment is a numeric index.\n */\nexport function setByPath(\n  obj: Record<string, unknown>,\n  path: string,\n  value: unknown,\n): void {\n  const segments = parseJsonPointer(path);\n\n  if (segments.length === 0) return;\n\n  let current: Record<string, unknown> | unknown[] = obj;\n\n  for (let i = 0; i < segments.length - 1; i++) {\n    const segment = segments[i]!;\n    const nextSegment = segments[i + 1];\n    const nextIsNumeric =\n      nextSegment !== undefined &&\n      (isNumericIndex(nextSegment) || nextSegment === \"-\");\n\n    if (Array.isArray(current)) {\n      const index = parseInt(segment, 10);\n      if (current[index] === undefined || typeof current[index] !== \"object\") {\n        current[index] = nextIsNumeric ? [] : {};\n      }\n      current = current[index] as Record<string, unknown> | unknown[];\n    } else {\n      if (!(segment in current) || typeof current[segment] !== \"object\") {\n        current[segment] = nextIsNumeric ? [] : {};\n      }\n      current = current[segment] as Record<string, unknown> | unknown[];\n    }\n  }\n\n  const lastSegment = segments[segments.length - 1]!;\n  if (Array.isArray(current)) {\n    if (lastSegment === \"-\") {\n      current.push(value);\n    } else {\n      const index = parseInt(lastSegment, 10);\n      current[index] = value;\n    }\n  } else {\n    current[lastSegment] = value;\n  }\n}\n\n/**\n * Add a value per RFC 6902 \"add\" semantics.\n * For objects: create-or-replace the member.\n * For arrays: insert before the given index, or append if \"-\".\n */\nexport function addByPath(\n  obj: Record<string, unknown>,\n  path: string,\n  value: unknown,\n): void {\n  const segments = parseJsonPointer(path);\n\n  if (segments.length === 0) return;\n\n  let current: Record<string, unknown> | unknown[] = obj;\n\n  for (let i = 0; i < segments.length - 1; i++) {\n    const segment = segments[i]!;\n    const nextSegment = segments[i + 1];\n    const nextIsNumeric =\n      nextSegment !== undefined &&\n      (isNumericIndex(nextSegment) || nextSegment === \"-\");\n\n    if (Array.isArray(current)) {\n      const index = parseInt(segment, 10);\n      if (current[index] === undefined || typeof current[index] !== \"object\") {\n        current[index] = nextIsNumeric ? [] : {};\n      }\n      current = current[index] as Record<string, unknown> | unknown[];\n    } else {\n      if (!(segment in current) || typeof current[segment] !== \"object\") {\n        current[segment] = nextIsNumeric ? [] : {};\n      }\n      current = current[segment] as Record<string, unknown> | unknown[];\n    }\n  }\n\n  const lastSegment = segments[segments.length - 1]!;\n  if (Array.isArray(current)) {\n    if (lastSegment === \"-\") {\n      current.push(value);\n    } else {\n      const index = parseInt(lastSegment, 10);\n      current.splice(index, 0, value);\n    }\n  } else {\n    current[lastSegment] = value;\n  }\n}\n\n/**\n * Remove a value per RFC 6902 \"remove\" semantics.\n * For objects: delete the property.\n * For arrays: splice out the element at the given index.\n */\nexport function removeByPath(obj: Record<string, unknown>, path: string): void {\n  const segments = parseJsonPointer(path);\n\n  if (segments.length === 0) return;\n\n  let current: Record<string, unknown> | unknown[] = obj;\n\n  for (let i = 0; i < segments.length - 1; i++) {\n    const segment = segments[i]!;\n\n    if (Array.isArray(current)) {\n      const index = parseInt(segment, 10);\n      if (current[index] === undefined || typeof current[index] !== \"object\") {\n        return; // path does not exist\n      }\n      current = current[index] as Record<string, unknown> | unknown[];\n    } else {\n      if (!(segment in current) || typeof current[segment] !== \"object\") {\n        return; // path does not exist\n      }\n      current = current[segment] as Record<string, unknown> | unknown[];\n    }\n  }\n\n  const lastSegment = segments[segments.length - 1]!;\n  if (Array.isArray(current)) {\n    const index = parseInt(lastSegment, 10);\n    if (index >= 0 && index < current.length) {\n      current.splice(index, 1);\n    }\n  } else {\n    delete current[lastSegment];\n  }\n}\n\n/**\n * Deep equality check for RFC 6902 \"test\" operation.\n */\nfunction deepEqual(a: unknown, b: unknown): boolean {\n  if (a === b) return true;\n  if (a === null || b === null) return false;\n  if (typeof a !== typeof b) return false;\n  if (typeof a !== \"object\") return false;\n\n  if (Array.isArray(a)) {\n    if (!Array.isArray(b)) return false;\n    if (a.length !== b.length) return false;\n    return a.every((item, i) => deepEqual(item, b[i]));\n  }\n\n  const aObj = a as Record<string, unknown>;\n  const bObj = b as Record<string, unknown>;\n  const aKeys = Object.keys(aObj);\n  const bKeys = Object.keys(bObj);\n\n  if (aKeys.length !== bKeys.length) return false;\n  return aKeys.every((key) => deepEqual(aObj[key], bObj[key]));\n}\n\n/**\n * Find a form value from params and/or state.\n * Useful in action handlers to locate form input values regardless of path format.\n *\n * Checks in order:\n * 1. Direct param key (if not a path reference)\n * 2. Param keys ending with the field name\n * 3. State keys ending with the field name (dot notation)\n * 4. State path using getByPath (slash notation)\n *\n * @example\n * // Find \"name\" from params or state\n * const name = findFormValue(\"name\", params, state);\n *\n * // Will find from: params.name, params[\"form.name\"], state[\"form.name\"], or getByPath(state, \"name\")\n */\nexport function findFormValue(\n  fieldName: string,\n  params?: Record<string, unknown>,\n  state?: Record<string, unknown>,\n): unknown {\n  // Check params first (but not if it looks like a state path reference)\n  if (params?.[fieldName] !== undefined) {\n    const val = params[fieldName];\n    // If the value looks like a path reference (contains dots), skip it\n    if (typeof val !== \"string\" || !val.includes(\".\")) {\n      return val;\n    }\n  }\n\n  // Check param keys that end with the field name\n  if (params) {\n    for (const key of Object.keys(params)) {\n      if (key.endsWith(`.${fieldName}`)) {\n        const val = params[key];\n        if (typeof val !== \"string\" || !val.includes(\".\")) {\n          return val;\n        }\n      }\n    }\n  }\n\n  // Check state keys that end with the field name (handles any form naming)\n  if (state) {\n    for (const key of Object.keys(state)) {\n      if (key === fieldName || key.endsWith(`.${fieldName}`)) {\n        return state[key];\n      }\n    }\n\n    // Try getByPath with the raw field name\n    const val = getByPath(state, fieldName);\n    if (val !== undefined) {\n      return val;\n    }\n  }\n\n  return undefined;\n}\n\n// =============================================================================\n// SpecStream - Streaming format for progressively building specs\n// =============================================================================\n\n/**\n * A SpecStream line - a single patch operation in the stream.\n */\nexport type SpecStreamLine = JsonPatch;\n\n/**\n * Parse a single SpecStream line into a patch operation.\n * Returns null if the line is invalid or empty.\n *\n * SpecStream is json-render's streaming format where each line is a JSON patch\n * operation that progressively builds up the final spec.\n */\nexport function parseSpecStreamLine(line: string): SpecStreamLine | null {\n  const trimmed = line.trim();\n  if (!trimmed || !trimmed.startsWith(\"{\")) return null;\n\n  try {\n    const patch = JSON.parse(trimmed) as SpecStreamLine;\n    if (patch.op && patch.path !== undefined) {\n      return patch;\n    }\n    return null;\n  } catch {\n    return null;\n  }\n}\n\n/**\n * Apply a single RFC 6902 JSON Patch operation to an object.\n * Mutates the object in place.\n *\n * Supports all six RFC 6902 operations: add, remove, replace, move, copy, test.\n *\n * @throws {Error} If a \"test\" operation fails (value mismatch).\n */\nexport function applySpecStreamPatch<T extends Record<string, unknown>>(\n  obj: T,\n  patch: SpecStreamLine,\n): T {\n  switch (patch.op) {\n    case \"add\":\n      addByPath(obj, patch.path, patch.value);\n      break;\n    case \"replace\":\n      // RFC 6902: target must exist. For streaming tolerance we set regardless.\n      setByPath(obj, patch.path, patch.value);\n      break;\n    case \"remove\":\n      removeByPath(obj, patch.path);\n      break;\n    case \"move\": {\n      if (!patch.from) break;\n      const moveValue = getByPath(obj, patch.from);\n      removeByPath(obj, patch.from);\n      addByPath(obj, patch.path, moveValue);\n      break;\n    }\n    case \"copy\": {\n      if (!patch.from) break;\n      const copyValue = getByPath(obj, patch.from);\n      addByPath(obj, patch.path, copyValue);\n      break;\n    }\n    case \"test\": {\n      const actual = getByPath(obj, patch.path);\n      if (!deepEqual(actual, patch.value)) {\n        throw new Error(\n          `Test operation failed: value at \"${patch.path}\" does not match`,\n        );\n      }\n      break;\n    }\n  }\n  return obj;\n}\n\n/**\n * Apply a single RFC 6902 JSON Patch operation to a Spec.\n * Mutates the spec in place and returns it.\n *\n * This is a typed convenience wrapper around `applySpecStreamPatch` that\n * accepts a `Spec` directly without requiring a cast to `Record<string, unknown>`.\n *\n * Note: This mutates the spec. For React state updates, spread the result\n * to create a new reference: `setSpec({ ...applySpecPatch(spec, patch) })`.\n *\n * @example\n * let spec: Spec = { root: \"\", elements: {} };\n * applySpecPatch(spec, { op: \"add\", path: \"/root\", value: \"main\" });\n */\nexport function applySpecPatch(spec: Spec, patch: SpecStreamLine): Spec {\n  applySpecStreamPatch(spec as unknown as Record<string, unknown>, patch);\n  return spec;\n}\n\n// =============================================================================\n// Nested-to-Flat Conversion\n// =============================================================================\n\n/**\n * A nested spec node. This is the tree format that humans naturally write —\n * each node has inline `children` as an array of child node objects rather\n * than string keys.\n */\ninterface NestedNode {\n  type: string;\n  props: Record<string, unknown>;\n  children?: NestedNode[];\n  /** Any other top-level fields (visible, on, repeat, etc.) */\n  [key: string]: unknown;\n}\n\n/**\n * Convert a nested (tree-structured) spec into the flat `Spec` format used\n * by json-render renderers.\n *\n * In the nested format each node has inline `children` as an array of child\n * objects. This function walks the tree, assigns auto-generated keys\n * (`el-0`, `el-1`, ...), and produces a flat `{ root, elements, state }` spec.\n *\n * The top-level `state` field (if present on the root node) is hoisted to\n * `spec.state`.\n *\n * @example\n * ```ts\n * const nested = {\n *   type: \"Card\",\n *   props: { title: \"Hello\" },\n *   children: [\n *     { type: \"Text\", props: { content: \"World\" } },\n *   ],\n *   state: { count: 0 },\n * };\n * const spec = nestedToFlat(nested);\n * // {\n * //   root: \"el-0\",\n * //   elements: {\n * //     \"el-0\": { type: \"Card\", props: { title: \"Hello\" }, children: [\"el-1\"] },\n * //     \"el-1\": { type: \"Text\", props: { content: \"World\" }, children: [] },\n * //   },\n * //   state: { count: 0 },\n * // }\n * ```\n */\nexport function nestedToFlat(nested: Record<string, unknown>): Spec {\n  const elements: Record<string, UIElement> = {};\n  let counter = 0;\n\n  function walk(node: Record<string, unknown>): string {\n    const key = `el-${counter++}`;\n    const { type, props, children: rawChildren, ...rest } = node as NestedNode;\n\n    // Recursively flatten children\n    const childKeys: string[] = [];\n    if (Array.isArray(rawChildren)) {\n      for (const child of rawChildren) {\n        if (child && typeof child === \"object\" && \"type\" in child) {\n          childKeys.push(walk(child as Record<string, unknown>));\n        }\n      }\n    }\n\n    // Build the flat element, preserving extra fields (visible, on, repeat, etc.)\n    // but excluding `state` which is hoisted to spec-level.\n    const element: UIElement = {\n      type: type ?? \"unknown\",\n      props: (props as Record<string, unknown>) ?? {},\n      children: childKeys,\n    };\n\n    // Copy extra fields (visible, on, repeat) but not state\n    for (const [k, v] of Object.entries(rest)) {\n      if (k !== \"state\" && v !== undefined) {\n        (element as unknown as Record<string, unknown>)[k] = v;\n      }\n    }\n\n    elements[key] = element;\n    return key;\n  }\n\n  const root = walk(nested);\n\n  const spec: Spec = { root, elements };\n\n  // Hoist state from root node if present\n  if (\n    nested.state &&\n    typeof nested.state === \"object\" &&\n    !Array.isArray(nested.state)\n  ) {\n    spec.state = nested.state as Record<string, unknown>;\n  }\n\n  return spec;\n}\n\n/**\n * Compile a SpecStream string into a JSON object.\n * Each line should be a patch operation.\n *\n * @example\n * const stream = `{\"op\":\"add\",\"path\":\"/name\",\"value\":\"Alice\"}\n * {\"op\":\"add\",\"path\":\"/age\",\"value\":30}`;\n * const result = compileSpecStream(stream);\n * // { name: \"Alice\", age: 30 }\n */\nexport function compileSpecStream<\n  T extends Record<string, unknown> = Record<string, unknown>,\n>(stream: string, initial: T = {} as T): T {\n  const lines = stream.split(\"\\n\");\n  const result = { ...initial };\n\n  for (const line of lines) {\n    const patch = parseSpecStreamLine(line);\n    if (patch) {\n      applySpecStreamPatch(result, patch);\n    }\n  }\n\n  return result as T;\n}\n\n/**\n * Streaming SpecStream compiler.\n * Useful for processing SpecStream data as it streams in from AI.\n *\n * @example\n * const compiler = createSpecStreamCompiler<MySpec>();\n *\n * // As chunks arrive:\n * const { result, newPatches } = compiler.push(chunk);\n * if (newPatches.length > 0) {\n *   updateUI(result);\n * }\n *\n * // When done:\n * const finalResult = compiler.getResult();\n */\nexport interface SpecStreamCompiler<T> {\n  /** Push a chunk of text. Returns the current result and any new patches applied. */\n  push(chunk: string): { result: T; newPatches: SpecStreamLine[] };\n  /** Get the current compiled result */\n  getResult(): T;\n  /** Get all patches that have been applied */\n  getPatches(): SpecStreamLine[];\n  /** Reset the compiler to initial state */\n  reset(initial?: Partial<T>): void;\n}\n\n/**\n * Create a streaming SpecStream compiler.\n *\n * SpecStream is json-render's streaming format. AI outputs patch operations\n * line by line, and this compiler progressively builds the final spec.\n *\n * @example\n * const compiler = createSpecStreamCompiler<TimelineSpec>();\n *\n * // Process streaming response\n * const reader = response.body.getReader();\n * while (true) {\n *   const { done, value } = await reader.read();\n *   if (done) break;\n *\n *   const { result, newPatches } = compiler.push(decoder.decode(value));\n *   if (newPatches.length > 0) {\n *     setSpec(result); // Update UI with partial result\n *   }\n * }\n */\nexport function createSpecStreamCompiler<T = Record<string, unknown>>(\n  initial: Partial<T> = {},\n): SpecStreamCompiler<T> {\n  let result = { ...initial } as T;\n  let buffer = \"\";\n  const appliedPatches: SpecStreamLine[] = [];\n  const processedLines = new Set<string>();\n\n  return {\n    push(chunk: string): { result: T; newPatches: SpecStreamLine[] } {\n      buffer += chunk;\n      const newPatches: SpecStreamLine[] = [];\n\n      // Process complete lines\n      const lines = buffer.split(\"\\n\");\n      buffer = lines.pop() || \"\"; // Keep incomplete line in buffer\n\n      for (const line of lines) {\n        const trimmed = line.trim();\n        if (!trimmed || processedLines.has(trimmed)) continue;\n        processedLines.add(trimmed);\n\n        const patch = parseSpecStreamLine(trimmed);\n        if (patch) {\n          applySpecStreamPatch(result as Record<string, unknown>, patch);\n          appliedPatches.push(patch);\n          newPatches.push(patch);\n        }\n      }\n\n      // Return a shallow copy to trigger re-renders\n      if (newPatches.length > 0) {\n        result = { ...result };\n      }\n\n      return { result, newPatches };\n    },\n\n    getResult(): T {\n      // Process any remaining buffer\n      if (buffer.trim()) {\n        const patch = parseSpecStreamLine(buffer);\n        if (patch && !processedLines.has(buffer.trim())) {\n          processedLines.add(buffer.trim());\n          applySpecStreamPatch(result as Record<string, unknown>, patch);\n          appliedPatches.push(patch);\n          result = { ...result };\n        }\n        buffer = \"\";\n      }\n      return result;\n    },\n\n    getPatches(): SpecStreamLine[] {\n      return [...appliedPatches];\n    },\n\n    reset(newInitial: Partial<T> = {}): void {\n      result = { ...newInitial } as T;\n      buffer = \"\";\n      appliedPatches.length = 0;\n      processedLines.clear();\n    },\n  };\n}\n\n// =============================================================================\n// Mixed Stream Parser — for chat + GenUI (text interleaved with JSONL patches)\n// =============================================================================\n\n/**\n * Callbacks for the mixed stream parser.\n */\nexport interface MixedStreamCallbacks {\n  /** Called when a JSONL patch line is parsed */\n  onPatch: (patch: SpecStreamLine) => void;\n  /** Called when a text (non-JSONL) line is received */\n  onText: (text: string) => void;\n}\n\n/**\n * A stateful parser for mixed streams that contain both text and JSONL patches.\n * Used in chat + GenUI scenarios where an LLM responds with conversational text\n * interleaved with json-render JSONL patch operations.\n */\nexport interface MixedStreamParser {\n  /** Push a chunk of streamed data. Calls onPatch/onText for each complete line. */\n  push(chunk: string): void;\n  /** Flush any remaining buffered content. Call when the stream ends. */\n  flush(): void;\n}\n\n/**\n * Create a parser for mixed text + JSONL streams.\n *\n * In chat + GenUI scenarios, an LLM streams a response that contains both\n * conversational text and json-render JSONL patch lines. This parser buffers\n * incoming chunks, splits them into lines, and classifies each line as either\n * a JSONL patch (via `parseSpecStreamLine`) or plain text.\n *\n * @example\n * const parser = createMixedStreamParser({\n *   onText: (text) => appendToMessage(text),\n *   onPatch: (patch) => applySpecPatch(spec, patch),\n * });\n *\n * // As chunks arrive from the stream:\n * for await (const chunk of stream) {\n *   parser.push(chunk);\n * }\n * parser.flush();\n */\nexport function createMixedStreamParser(\n  callbacks: MixedStreamCallbacks,\n): MixedStreamParser {\n  let buffer = \"\";\n  let inSpecFence = false;\n\n  function processLine(line: string): void {\n    const trimmed = line.trim();\n\n    // Fence detection\n    if (!inSpecFence && trimmed.startsWith(\"```spec\")) {\n      inSpecFence = true;\n      return;\n    }\n    if (inSpecFence && trimmed === \"```\") {\n      inSpecFence = false;\n      return;\n    }\n\n    if (!trimmed) return;\n\n    if (inSpecFence) {\n      const patch = parseSpecStreamLine(trimmed);\n      if (patch) {\n        callbacks.onPatch(patch);\n      }\n      return;\n    }\n\n    // Outside fence: heuristic mode\n    const patch = parseSpecStreamLine(trimmed);\n    if (patch) {\n      callbacks.onPatch(patch);\n    } else {\n      callbacks.onText(line);\n    }\n  }\n\n  return {\n    push(chunk: string): void {\n      buffer += chunk;\n\n      // Process complete lines\n      const lines = buffer.split(\"\\n\");\n      buffer = lines.pop() || \"\"; // Keep incomplete line in buffer\n\n      for (const line of lines) {\n        processLine(line);\n      }\n    },\n\n    flush(): void {\n      if (buffer.trim()) {\n        processLine(buffer);\n      }\n      buffer = \"\";\n    },\n  };\n}\n\n// =============================================================================\n// AI SDK Stream Transform\n// =============================================================================\n\n/**\n * Minimal chunk shape compatible with the AI SDK's `UIMessageChunk`.\n *\n * Defined here so that `@json-render/core` has no dependency on the `ai`\n * package. The discriminated union covers the three text-related chunk types\n * the transform inspects; all other chunk types pass through via the fallback.\n */\nexport type StreamChunk =\n  | { type: \"text-start\"; id: string; [k: string]: unknown }\n  | { type: \"text-delta\"; id: string; delta: string; [k: string]: unknown }\n  | { type: \"text-end\"; id: string; [k: string]: unknown }\n  | { type: string; [k: string]: unknown };\n\n/** The opening fence for a spec block (e.g. ` ```spec `). */\nconst SPEC_FENCE_OPEN = \"```spec\";\n/** The closing fence for a spec block. */\nconst SPEC_FENCE_CLOSE = \"```\";\n\n/**\n * Creates a `TransformStream` that intercepts AI SDK UI message stream chunks\n * and classifies text content as either prose or json-render JSONL patches.\n *\n * Two classification modes:\n *\n * 1. **Fence mode** (preferred): Lines between ` ```spec ` and ` ``` ` are\n *    parsed as JSONL patches. Fence delimiters are swallowed (not emitted).\n * 2. **Heuristic mode** (backward compat): Outside of fences, lines starting\n *    with `{` are buffered and tested with `parseSpecStreamLine`. Valid patches\n *    are emitted as {@link SPEC_DATA_PART_TYPE} parts; everything else is\n *    flushed as text.\n *\n * Non-text chunks (tool events, step markers, etc.) are passed through unchanged.\n *\n * @example\n * ```ts\n * import { createJsonRenderTransform } from \"@json-render/core\";\n * import { createUIMessageStream, createUIMessageStreamResponse } from \"ai\";\n *\n * const stream = createUIMessageStream({\n *   execute: async ({ writer }) => {\n *     writer.merge(\n *       result.toUIMessageStream().pipeThrough(createJsonRenderTransform()),\n *     );\n *   },\n * });\n * return createUIMessageStreamResponse({ stream });\n * ```\n */\nexport function createJsonRenderTransform(): TransformStream<\n  StreamChunk,\n  StreamChunk\n> {\n  let lineBuffer = \"\";\n  let currentTextId = \"\";\n  // Whether the current incomplete line might be JSONL (starts with '{')\n  let buffering = false;\n  // Whether we are inside a ```spec fence\n  let inSpecFence = false;\n\n  function emitPatch(\n    patch: SpecStreamLine,\n    controller: TransformStreamDefaultController<StreamChunk>,\n  ) {\n    controller.enqueue({\n      type: SPEC_DATA_PART_TYPE,\n      data: { type: \"patch\", patch },\n    });\n  }\n\n  function flushBuffer(\n    controller: TransformStreamDefaultController<StreamChunk>,\n  ) {\n    if (!lineBuffer) return;\n\n    const trimmed = lineBuffer.trim();\n\n    // Inside a fence, everything is spec data\n    if (inSpecFence) {\n      if (trimmed) {\n        const patch = parseSpecStreamLine(trimmed);\n        if (patch) emitPatch(patch, controller);\n        // Non-patch lines inside the fence are silently dropped\n      }\n      lineBuffer = \"\";\n      buffering = false;\n      return;\n    }\n\n    if (trimmed) {\n      const patch = parseSpecStreamLine(trimmed);\n      if (patch) {\n        emitPatch(patch, controller);\n      } else {\n        // Was buffered but isn't JSONL — flush as text\n        controller.enqueue({\n          type: \"text-delta\",\n          id: currentTextId,\n          delta: lineBuffer,\n        });\n      }\n    } else {\n      // Whitespace-only buffer — forward as-is (preserves blank lines)\n      controller.enqueue({\n        type: \"text-delta\",\n        id: currentTextId,\n        delta: lineBuffer,\n      });\n    }\n    lineBuffer = \"\";\n    buffering = false;\n  }\n\n  function processCompleteLine(\n    line: string,\n    controller: TransformStreamDefaultController<StreamChunk>,\n  ) {\n    const trimmed = line.trim();\n\n    // --- Fence detection ---\n    if (!inSpecFence && trimmed.startsWith(SPEC_FENCE_OPEN)) {\n      inSpecFence = true;\n      return; // Swallow the opening fence\n    }\n    if (inSpecFence && trimmed === SPEC_FENCE_CLOSE) {\n      inSpecFence = false;\n      return; // Swallow the closing fence\n    }\n\n    // Inside a fence: parse as spec data\n    if (inSpecFence) {\n      if (trimmed) {\n        const patch = parseSpecStreamLine(trimmed);\n        if (patch) emitPatch(patch, controller);\n      }\n      return;\n    }\n\n    // --- Outside fence: heuristic mode ---\n    if (!trimmed) {\n      // Empty line — forward for markdown paragraph breaks\n      controller.enqueue({\n        type: \"text-delta\",\n        id: currentTextId,\n        delta: \"\\n\",\n      });\n      return;\n    }\n\n    const patch = parseSpecStreamLine(trimmed);\n    if (patch) {\n      emitPatch(patch, controller);\n    } else {\n      controller.enqueue({\n        type: \"text-delta\",\n        id: currentTextId,\n        delta: line + \"\\n\",\n      });\n    }\n  }\n\n  return new TransformStream<StreamChunk, StreamChunk>({\n    transform(chunk, controller) {\n      switch (chunk.type) {\n        case \"text-start\": {\n          currentTextId = (chunk as { id: string }).id;\n          controller.enqueue(chunk);\n          break;\n        }\n\n        case \"text-delta\": {\n          const delta = chunk as { id: string; delta: string };\n          currentTextId = delta.id;\n          const text = delta.delta;\n\n          for (let i = 0; i < text.length; i++) {\n            const ch = text.charAt(i);\n\n            if (ch === \"\\n\") {\n              // Line complete — classify and emit\n              if (buffering) {\n                processCompleteLine(lineBuffer, controller);\n                lineBuffer = \"\";\n                buffering = false;\n              } else {\n                // Outside fence, emit newline; inside fence, swallow it\n                if (!inSpecFence) {\n                  controller.enqueue({\n                    type: \"text-delta\",\n                    id: currentTextId,\n                    delta: \"\\n\",\n                  });\n                }\n              }\n            } else if (lineBuffer.length === 0 && !buffering) {\n              // Start of a new line — decide whether to buffer or stream\n              if (inSpecFence || ch === \"{\" || ch === \"`\") {\n                // Buffer: inside fence (everything), or heuristic mode ({), or potential fence (`)\n                buffering = true;\n                lineBuffer += ch;\n              } else {\n                controller.enqueue({\n                  type: \"text-delta\",\n                  id: currentTextId,\n                  delta: ch,\n                });\n              }\n            } else if (buffering) {\n              lineBuffer += ch;\n            } else {\n              controller.enqueue({\n                type: \"text-delta\",\n                id: currentTextId,\n                delta: ch,\n              });\n            }\n          }\n          break;\n        }\n\n        case \"text-end\": {\n          flushBuffer(controller);\n          controller.enqueue(chunk);\n          break;\n        }\n\n        default: {\n          controller.enqueue(chunk);\n          break;\n        }\n      }\n    },\n\n    flush(controller) {\n      flushBuffer(controller);\n    },\n  });\n}\n\n/**\n * The key registered in `AppDataParts` for json-render specs.\n * The AI SDK automatically prefixes this with `\"data-\"` on the wire,\n * so the actual stream chunk type is `\"data-spec\"` (see {@link SPEC_DATA_PART_TYPE}).\n *\n * @example\n * ```ts\n * import { SPEC_DATA_PART, type SpecDataPart } from \"@json-render/core\";\n * type AppDataParts = { [SPEC_DATA_PART]: SpecDataPart };\n * ```\n */\nexport const SPEC_DATA_PART = \"spec\" as const;\n\n/**\n * The wire-format type string as it appears in stream chunks and message parts.\n * This is `\"data-\"` + {@link SPEC_DATA_PART} — i.e. `\"data-spec\"`.\n *\n * Use this constant when filtering message parts or enqueuing stream chunks.\n */\nexport const SPEC_DATA_PART_TYPE = `data-${SPEC_DATA_PART}` as const;\n\n/**\n * Discriminated union for the payload of a {@link SPEC_DATA_PART_TYPE} SSE part.\n *\n * - `\"patch\"`: A single RFC 6902 JSON Patch operation (streaming, progressive UI).\n * - `\"flat\"`: A complete flat spec with `root`, `elements`, and optional `state`.\n * - `\"nested\"`: A complete nested spec (tree structure — schema depends on catalog).\n */\nexport type SpecDataPart =\n  | { type: \"patch\"; patch: JsonPatch }\n  | { type: \"flat\"; spec: Spec }\n  | { type: \"nested\"; spec: Record<string, unknown> };\n\n/**\n * Convenience wrapper that pipes an AI SDK UI message stream through the\n * json-render transform, classifying text as prose or JSONL patches.\n *\n * Eliminates the need for manual `pipeThrough(createJsonRenderTransform())`\n * and the associated type cast.\n *\n * @example\n * ```ts\n * import { pipeJsonRender } from \"@json-render/core\";\n *\n * const stream = createUIMessageStream({\n *   execute: async ({ writer }) => {\n *     writer.merge(pipeJsonRender(result.toUIMessageStream()));\n *   },\n * });\n * return createUIMessageStreamResponse({ stream });\n * ```\n */\nexport function pipeJsonRender<T = StreamChunk>(\n  stream: ReadableStream<T>,\n): ReadableStream<T> {\n  return stream.pipeThrough(\n    createJsonRenderTransform() as unknown as TransformStream<T, T>,\n  );\n}\n","import { z } from \"zod\";\nimport type {\n  VisibilityCondition,\n  StateCondition,\n  ItemCondition,\n  IndexCondition,\n  SingleCondition,\n  AndCondition,\n  OrCondition,\n  StateModel,\n} from \"./types\";\nimport { getByPath } from \"./types\";\n\n// =============================================================================\n// Schemas\n// =============================================================================\n\n/**\n * Schema for a single state condition.\n */\nconst numericOrStateRef = z.union([\n  z.number(),\n  z.object({ $state: z.string() }),\n]);\n\nconst comparisonOps = {\n  eq: z.unknown().optional(),\n  neq: z.unknown().optional(),\n  gt: numericOrStateRef.optional(),\n  gte: numericOrStateRef.optional(),\n  lt: numericOrStateRef.optional(),\n  lte: numericOrStateRef.optional(),\n  not: z.literal(true).optional(),\n};\n\nconst StateConditionSchema = z.object({\n  $state: z.string(),\n  ...comparisonOps,\n});\n\nconst ItemConditionSchema = z.object({\n  $item: z.string(),\n  ...comparisonOps,\n});\n\nconst IndexConditionSchema = z.object({\n  $index: z.literal(true),\n  ...comparisonOps,\n});\n\nconst SingleConditionSchema = z.union([\n  StateConditionSchema,\n  ItemConditionSchema,\n  IndexConditionSchema,\n]);\n\n/**\n * Visibility condition schema.\n *\n * Lazy because `OrCondition` can recursively contain `VisibilityCondition`.\n */\nexport const VisibilityConditionSchema: z.ZodType<VisibilityCondition> = z.lazy(\n  () =>\n    z.union([\n      z.boolean(),\n      SingleConditionSchema,\n      z.array(SingleConditionSchema),\n      z.object({ $and: z.array(VisibilityConditionSchema) }),\n      z.object({ $or: z.array(VisibilityConditionSchema) }),\n    ]),\n);\n\n// =============================================================================\n// Context\n// =============================================================================\n\n/**\n * Context for evaluating visibility conditions.\n *\n * `repeatItem` and `repeatIndex` are only present inside a `repeat` scope\n * and enable `$item` / `$index` conditions.\n */\nexport interface VisibilityContext {\n  stateModel: StateModel;\n  /** The current repeat item (set inside a repeat scope). */\n  repeatItem?: unknown;\n  /** The current repeat array index (set inside a repeat scope). */\n  repeatIndex?: number;\n}\n\n// =============================================================================\n// Evaluation\n// =============================================================================\n\n/**\n * Resolve a comparison value. If it's a `{ $state }` reference, look it up;\n * otherwise return the literal.\n */\nfunction resolveComparisonValue(\n  value: unknown,\n  ctx: VisibilityContext,\n): unknown {\n  if (typeof value === \"object\" && value !== null) {\n    if (\n      \"$state\" in value &&\n      typeof (value as Record<string, unknown>).$state === \"string\"\n    ) {\n      return getByPath(ctx.stateModel, (value as { $state: string }).$state);\n    }\n  }\n  return value;\n}\n\n/**\n * Type guards for condition sources.\n */\nfunction isItemCondition(cond: SingleCondition): cond is ItemCondition {\n  return \"$item\" in cond;\n}\n\nfunction isIndexCondition(cond: SingleCondition): cond is IndexCondition {\n  return \"$index\" in cond;\n}\n\n/**\n * Resolve the left-hand-side value of a condition based on its source.\n */\nfunction resolveConditionValue(\n  cond: SingleCondition,\n  ctx: VisibilityContext,\n): unknown {\n  if (isIndexCondition(cond)) {\n    return ctx.repeatIndex;\n  }\n  if (isItemCondition(cond)) {\n    if (ctx.repeatItem === undefined) return undefined;\n    return cond.$item === \"\"\n      ? ctx.repeatItem\n      : getByPath(ctx.repeatItem, cond.$item);\n  }\n  // StateCondition\n  return getByPath(ctx.stateModel, (cond as StateCondition).$state);\n}\n\n/**\n * Evaluate a single condition against the context.\n *\n * When `not` is `true`, the final result is inverted — this applies to\n * whichever operator is present (or to the truthiness check if no operator\n * is given).  For example:\n * - `{ $state: \"/x\", not: true }` → `!Boolean(value)`\n * - `{ $state: \"/x\", gt: 5, not: true }` → `!(value > 5)`\n */\nfunction evaluateCondition(\n  cond: SingleCondition,\n  ctx: VisibilityContext,\n): boolean {\n  const value = resolveConditionValue(cond, ctx);\n  let result: boolean;\n\n  // Equality\n  if (cond.eq !== undefined) {\n    const rhs = resolveComparisonValue(cond.eq, ctx);\n    result = value === rhs;\n  }\n  // Inequality\n  else if (cond.neq !== undefined) {\n    const rhs = resolveComparisonValue(cond.neq, ctx);\n    result = value !== rhs;\n  }\n  // Greater than\n  else if (cond.gt !== undefined) {\n    const rhs = resolveComparisonValue(cond.gt, ctx);\n    result =\n      typeof value === \"number\" && typeof rhs === \"number\"\n        ? value > rhs\n        : false;\n  }\n  // Greater than or equal\n  else if (cond.gte !== undefined) {\n    const rhs = resolveComparisonValue(cond.gte, ctx);\n    result =\n      typeof value === \"number\" && typeof rhs === \"number\"\n        ? value >= rhs\n        : false;\n  }\n  // Less than\n  else if (cond.lt !== undefined) {\n    const rhs = resolveComparisonValue(cond.lt, ctx);\n    result =\n      typeof value === \"number\" && typeof rhs === \"number\"\n        ? value < rhs\n        : false;\n  }\n  // Less than or equal\n  else if (cond.lte !== undefined) {\n    const rhs = resolveComparisonValue(cond.lte, ctx);\n    result =\n      typeof value === \"number\" && typeof rhs === \"number\"\n        ? value <= rhs\n        : false;\n  }\n  // Truthiness (no operator)\n  else {\n    result = Boolean(value);\n  }\n\n  // `not` inverts the result of any condition\n  return cond.not === true ? !result : result;\n}\n\n/**\n * Type guard for AndCondition\n */\nfunction isAndCondition(\n  condition: VisibilityCondition,\n): condition is AndCondition {\n  return (\n    typeof condition === \"object\" &&\n    condition !== null &&\n    !Array.isArray(condition) &&\n    \"$and\" in condition\n  );\n}\n\n/**\n * Type guard for OrCondition\n */\nfunction isOrCondition(\n  condition: VisibilityCondition,\n): condition is OrCondition {\n  return (\n    typeof condition === \"object\" &&\n    condition !== null &&\n    !Array.isArray(condition) &&\n    \"$or\" in condition\n  );\n}\n\n/**\n * Evaluate a visibility condition.\n *\n * - `undefined` → visible\n * - `boolean` → that value\n * - `SingleCondition` → evaluate single condition\n * - `SingleCondition[]` → implicit AND (all must be true)\n * - `AndCondition` → `{ $and: [...] }`, explicit AND\n * - `OrCondition` → `{ $or: [...] }`, at least one must be true\n */\nexport function evaluateVisibility(\n  condition: VisibilityCondition | undefined,\n  ctx: VisibilityContext,\n): boolean {\n  // No condition = visible\n  if (condition === undefined) {\n    return true;\n  }\n\n  // Boolean literal\n  if (typeof condition === \"boolean\") {\n    return condition;\n  }\n\n  // Array = implicit AND\n  if (Array.isArray(condition)) {\n    return condition.every((c) => evaluateCondition(c, ctx));\n  }\n\n  // Explicit AND condition\n  if (isAndCondition(condition)) {\n    return condition.$and.every((child) => evaluateVisibility(child, ctx));\n  }\n\n  // OR condition\n  if (isOrCondition(condition)) {\n    return condition.$or.some((child) => evaluateVisibility(child, ctx));\n  }\n\n  // Single condition\n  return evaluateCondition(condition, ctx);\n}\n\n// =============================================================================\n// Helpers\n// =============================================================================\n\n/**\n * Helper to create visibility conditions.\n */\nexport const visibility = {\n  /** Always visible */\n  always: true as const,\n\n  /** Never visible */\n  never: false as const,\n\n  /** Visible when state path is truthy */\n  when: (path: string): StateCondition => ({ $state: path }),\n\n  /** Visible when state path is falsy */\n  unless: (path: string): StateCondition => ({ $state: path, not: true }),\n\n  /** Equality check */\n  eq: (path: string, value: unknown): StateCondition => ({\n    $state: path,\n    eq: value,\n  }),\n\n  /** Not equal check */\n  neq: (path: string, value: unknown): StateCondition => ({\n    $state: path,\n    neq: value,\n  }),\n\n  /** Greater than */\n  gt: (path: string, value: number | { $state: string }): StateCondition => ({\n    $state: path,\n    gt: value,\n  }),\n\n  /** Greater than or equal */\n  gte: (path: string, value: number | { $state: string }): StateCondition => ({\n    $state: path,\n    gte: value,\n  }),\n\n  /** Less than */\n  lt: (path: string, value: number | { $state: string }): StateCondition => ({\n    $state: path,\n    lt: value,\n  }),\n\n  /** Less than or equal */\n  lte: (path: string, value: number | { $state: string }): StateCondition => ({\n    $state: path,\n    lte: value,\n  }),\n\n  /** AND multiple conditions */\n  and: (...conditions: VisibilityCondition[]): AndCondition => ({\n    $and: conditions,\n  }),\n\n  /** OR multiple conditions */\n  or: (...conditions: VisibilityCondition[]): OrCondition => ({\n    $or: conditions,\n  }),\n};\n","import type { VisibilityCondition, StateModel } from \"./types\";\nimport { getByPath } from \"./types\";\nimport { evaluateVisibility, type VisibilityContext } from \"./visibility\";\n\n// =============================================================================\n// Prop Expression Types\n// =============================================================================\n\n/**\n * A prop expression that resolves to a value based on state.\n *\n * - `{ $state: string }` reads a value from the global state model\n * - `{ $item: string }` reads a field from the current repeat item\n *    (relative path into the item object; use `\"\"` for the whole item)\n * - `{ $index: true }` returns the current repeat array index. Uses `true`\n *    as a sentinel flag because the index is a scalar with no sub-path to\n *    navigate — unlike `$item` which needs a path into the item object.\n * - `{ $bindState: string }` two-way binding to a global state path —\n *    resolves to the value at the path (like `$state`) AND exposes the\n *    resolved path so the component can write back.\n * - `{ $bindItem: string }` two-way binding to a field on the current\n *    repeat item — resolves via `repeatBasePath + path` and exposes the\n *    absolute state path for write-back.\n * - `{ $cond, $then, $else }` conditionally picks a value\n * - Any other value is a literal (passthrough)\n */\nexport type PropExpression<T = unknown> =\n  | T\n  | { $state: string }\n  | { $item: string }\n  | { $index: true }\n  | { $bindState: string }\n  | { $bindItem: string }\n  | {\n      $cond: VisibilityCondition;\n      $then: PropExpression<T>;\n      $else: PropExpression<T>;\n    };\n\n/**\n * Context for resolving prop expressions.\n * Extends {@link VisibilityContext} with an optional `repeatBasePath` used\n * to resolve `$bindItem` paths to absolute state paths.\n */\nexport interface PropResolutionContext extends VisibilityContext {\n  /** Absolute state path to the current repeat item (e.g. \"/todos/0\"). Set inside repeat scopes. */\n  repeatBasePath?: string;\n}\n\n// =============================================================================\n// Type Guards\n// =============================================================================\n\nfunction isStateExpression(value: unknown): value is { $state: string } {\n  return (\n    typeof value === \"object\" &&\n    value !== null &&\n    \"$state\" in value &&\n    typeof (value as Record<string, unknown>).$state === \"string\"\n  );\n}\n\nfunction isItemExpression(value: unknown): value is { $item: string } {\n  return (\n    typeof value === \"object\" &&\n    value !== null &&\n    \"$item\" in value &&\n    typeof (value as Record<string, unknown>).$item === \"string\"\n  );\n}\n\nfunction isIndexExpression(value: unknown): value is { $index: true } {\n  return (\n    typeof value === \"object\" &&\n    value !== null &&\n    \"$index\" in value &&\n    (value as Record<string, unknown>).$index === true\n  );\n}\n\nfunction isBindStateExpression(\n  value: unknown,\n): value is { $bindState: string } {\n  return (\n    typeof value === \"object\" &&\n    value !== null &&\n    \"$bindState\" in value &&\n    typeof (value as Record<string, unknown>).$bindState === \"string\"\n  );\n}\n\nfunction isBindItemExpression(value: unknown): value is { $bindItem: string } {\n  return (\n    typeof value === \"object\" &&\n    value !== null &&\n    \"$bindItem\" in value &&\n    typeof (value as Record<string, unknown>).$bindItem === \"string\"\n  );\n}\n\nfunction isCondExpression(\n  value: unknown,\n): value is { $cond: VisibilityCondition; $then: unknown; $else: unknown } {\n  return (\n    typeof value === \"object\" &&\n    value !== null &&\n    \"$cond\" in value &&\n    \"$then\" in value &&\n    \"$else\" in value\n  );\n}\n\n// =============================================================================\n// Prop Expression Resolution\n// =============================================================================\n\n// =============================================================================\n// $bindItem path resolution helper\n// =============================================================================\n\n/**\n * Resolve a `$bindItem` path into an absolute state path using the repeat\n * scope's base path.\n *\n * `\"\"` resolves to `repeatBasePath` (the whole item).\n * `\"field\"` resolves to `repeatBasePath + \"/field\"`.\n *\n * Returns `undefined` when no `repeatBasePath` is available (i.e. `$bindItem`\n * is used outside a repeat scope).\n */\nfunction resolveBindItemPath(\n  itemPath: string,\n  ctx: PropResolutionContext,\n): string | undefined {\n  if (ctx.repeatBasePath == null) {\n    console.warn(`$bindItem used outside repeat scope: \"${itemPath}\"`);\n    return undefined;\n  }\n  if (itemPath === \"\") return ctx.repeatBasePath;\n  return ctx.repeatBasePath + \"/\" + itemPath;\n}\n\n// =============================================================================\n// Prop Expression Resolution\n// =============================================================================\n\n/**\n * Resolve a single prop value that may contain expressions.\n * Handles $state, $item, $index, $bindState, $bindItem, and $cond/$then/$else in a single pass.\n */\nexport function resolvePropValue(\n  value: unknown,\n  ctx: PropResolutionContext,\n): unknown {\n  if (value === null || value === undefined) {\n    return value;\n  }\n\n  // $state: read from global state model\n  if (isStateExpression(value)) {\n    return getByPath(ctx.stateModel, value.$state);\n  }\n\n  // $item: read from current repeat item\n  if (isItemExpression(value)) {\n    if (ctx.repeatItem === undefined) return undefined;\n    // \"\" means the whole item, \"field\" means a field on the item\n    return value.$item === \"\"\n      ? ctx.repeatItem\n      : getByPath(ctx.repeatItem, value.$item);\n  }\n\n  // $index: return current repeat array index\n  if (isIndexExpression(value)) {\n    return ctx.repeatIndex;\n  }\n\n  // $bindState: two-way binding to global state path\n  if (isBindStateExpression(value)) {\n    return getByPath(ctx.stateModel, value.$bindState);\n  }\n\n  // $bindItem: two-way binding to repeat item field\n  if (isBindItemExpression(value)) {\n    const resolvedPath = resolveBindItemPath(value.$bindItem, ctx);\n    if (resolvedPath === undefined) return undefined;\n    return getByPath(ctx.stateModel, resolvedPath);\n  }\n\n  // $cond/$then/$else: evaluate condition and pick branch\n  if (isCondExpression(value)) {\n    const result = evaluateVisibility(value.$cond, ctx);\n    return resolvePropValue(result ? value.$then : value.$else, ctx);\n  }\n\n  // Arrays: resolve each element\n  if (Array.isArray(value)) {\n    return value.map((item) => resolvePropValue(item, ctx));\n  }\n\n  // Plain objects (not expressions): resolve each value recursively\n  if (typeof value === \"object\") {\n    const resolved: Record<string, unknown> = {};\n    for (const [key, val] of Object.entries(value as Record<string, unknown>)) {\n      resolved[key] = resolvePropValue(val, ctx);\n    }\n    return resolved;\n  }\n\n  // Primitive literal: passthrough\n  return value;\n}\n\n/**\n * Resolve all prop values in an element's props object.\n * Returns a new props object with all expressions resolved.\n */\nexport function resolveElementProps(\n  props: Record<string, unknown>,\n  ctx: PropResolutionContext,\n): Record<string, unknown> {\n  const resolved: Record<string, unknown> = {};\n  for (const [key, value] of Object.entries(props)) {\n    resolved[key] = resolvePropValue(value, ctx);\n  }\n  return resolved;\n}\n\n/**\n * Scan an element's raw props for `$bindState` / `$bindItem` expressions\n * and return a map of prop name → resolved absolute state path.\n *\n * This is called **before** `resolveElementProps` so the component can\n * receive both the resolved value (in `props`) and the write-back path\n * (in `bindings`).\n *\n * @example\n * ```ts\n * const rawProps = { value: { $bindState: \"/form/email\" }, label: \"Email\" };\n * const bindings = resolveBindings(rawProps, ctx);\n * // bindings = { value: \"/form/email\" }\n * ```\n */\nexport function resolveBindings(\n  props: Record<string, unknown>,\n  ctx: PropResolutionContext,\n): Record<string, string> | undefined {\n  let bindings: Record<string, string> | undefined;\n  for (const [key, value] of Object.entries(props)) {\n    if (isBindStateExpression(value)) {\n      if (!bindings) bindings = {};\n      bindings[key] = value.$bindState;\n    } else if (isBindItemExpression(value)) {\n      const resolved = resolveBindItemPath(value.$bindItem, ctx);\n      if (resolved !== undefined) {\n        if (!bindings) bindings = {};\n        bindings[key] = resolved;\n      }\n    }\n  }\n  return bindings;\n}\n\n/**\n * Resolve a single action parameter value.\n *\n * Like {@link resolvePropValue} but with special handling for path-valued\n * params: `{ $item: \"field\" }` resolves to an **absolute state path**\n * (e.g. `/todos/0/field`) instead of the field's value, so the path can\n * be passed to `setState` / `pushState` / `removeState`.\n *\n * - `{ $item: \"field\" }` → absolute state path via `repeatBasePath`\n * - `{ $index: true }` → current repeat index (number)\n * - Everything else delegates to `resolvePropValue` ($state, $cond, literals).\n */\nexport function resolveActionParam(\n  value: unknown,\n  ctx: PropResolutionContext,\n): unknown {\n  if (isItemExpression(value)) {\n    return resolveBindItemPath(value.$item, ctx);\n  }\n  if (isIndexExpression(value)) {\n    return ctx.repeatIndex;\n  }\n  return resolvePropValue(value, ctx);\n}\n","import { z } from \"zod\";\nimport type { DynamicValue, StateModel } from \"./types\";\nimport { DynamicValueSchema, resolveDynamicValue } from \"./types\";\n\n/**\n * Confirmation dialog configuration\n */\nexport interface ActionConfirm {\n  title: string;\n  message: string;\n  confirmLabel?: string;\n  cancelLabel?: string;\n  variant?: \"default\" | \"danger\";\n}\n\n/**\n * Action success handler\n */\nexport type ActionOnSuccess =\n  | { navigate: string }\n  | { set: Record<string, unknown> }\n  | { action: string };\n\n/**\n * Action error handler\n */\nexport type ActionOnError =\n  | { set: Record<string, unknown> }\n  | { action: string };\n\n/**\n * Action binding — maps an event to an action invocation.\n *\n * Used inside the `on` field of a UIElement:\n * ```json\n * { \"on\": { \"press\": { \"action\": \"setState\", \"params\": { \"statePath\": \"/x\", \"value\": 1 } } } }\n * ```\n */\nexport interface ActionBinding {\n  /** Action name (must be in catalog) */\n  action: string;\n  /** Parameters to pass to the action handler */\n  params?: Record<string, DynamicValue>;\n  /** Confirmation dialog before execution */\n  confirm?: ActionConfirm;\n  /** Handler after successful execution */\n  onSuccess?: ActionOnSuccess;\n  /** Handler after failed execution */\n  onError?: ActionOnError;\n}\n\n/**\n * @deprecated Use ActionBinding instead\n */\nexport type Action = ActionBinding;\n\n/**\n * Schema for action confirmation\n */\nexport const ActionConfirmSchema = z.object({\n  title: z.string(),\n  message: z.string(),\n  confirmLabel: z.string().optional(),\n  cancelLabel: z.string().optional(),\n  variant: z.enum([\"default\", \"danger\"]).optional(),\n});\n\n/**\n * Schema for success handlers\n */\nexport const ActionOnSuccessSchema = z.union([\n  z.object({ navigate: z.string() }),\n  z.object({ set: z.record(z.string(), z.unknown()) }),\n  z.object({ action: z.string() }),\n]);\n\n/**\n * Schema for error handlers\n */\nexport const ActionOnErrorSchema = z.union([\n  z.object({ set: z.record(z.string(), z.unknown()) }),\n  z.object({ action: z.string() }),\n]);\n\n/**\n * Full action binding schema\n */\nexport const ActionBindingSchema = z.object({\n  action: z.string(),\n  params: z.record(z.string(), DynamicValueSchema).optional(),\n  confirm: ActionConfirmSchema.optional(),\n  onSuccess: ActionOnSuccessSchema.optional(),\n  onError: ActionOnErrorSchema.optional(),\n});\n\n/**\n * @deprecated Use ActionBindingSchema instead\n */\nexport const ActionSchema = ActionBindingSchema;\n\n/**\n * Action handler function signature\n */\nexport type ActionHandler<\n  TParams = Record<string, unknown>,\n  TResult = unknown,\n> = (params: TParams) => Promise<TResult> | TResult;\n\n/**\n * Action definition in catalog\n */\nexport interface ActionDefinition<TParams = Record<string, unknown>> {\n  /** Zod schema for params validation */\n  params?: z.ZodType<TParams>;\n  /** Description for AI */\n  description?: string;\n}\n\n/**\n * Resolved action with all dynamic values resolved\n */\nexport interface ResolvedAction {\n  action: string;\n  params: Record<string, unknown>;\n  confirm?: ActionConfirm;\n  onSuccess?: ActionOnSuccess;\n  onError?: ActionOnError;\n}\n\n/**\n * Resolve all dynamic values in an action binding\n */\nexport function resolveAction(\n  binding: ActionBinding,\n  stateModel: StateModel,\n): ResolvedAction {\n  const resolvedParams: Record<string, unknown> = {};\n\n  if (binding.params) {\n    for (const [key, value] of Object.entries(binding.params)) {\n      resolvedParams[key] = resolveDynamicValue(value, stateModel);\n    }\n  }\n\n  // Interpolate confirmation message if present\n  let confirm = binding.confirm;\n  if (confirm) {\n    confirm = {\n      ...confirm,\n      message: interpolateString(confirm.message, stateModel),\n      title: interpolateString(confirm.title, stateModel),\n    };\n  }\n\n  return {\n    action: binding.action,\n    params: resolvedParams,\n    confirm,\n    onSuccess: binding.onSuccess,\n    onError: binding.onError,\n  };\n}\n\n/**\n * Interpolate ${path} expressions in a string\n */\nexport function interpolateString(\n  template: string,\n  stateModel: StateModel,\n): string {\n  return template.replace(/\\$\\{([^}]+)\\}/g, (_, path) => {\n    const value = resolveDynamicValue({ $state: path }, stateModel);\n    return String(value ?? \"\");\n  });\n}\n\n/**\n * Context for action execution\n */\nexport interface ActionExecutionContext {\n  /** The resolved action */\n  action: ResolvedAction;\n  /** The action handler from the host */\n  handler: ActionHandler;\n  /** Function to update state model */\n  setState: (path: string, value: unknown) => void;\n  /** Function to navigate */\n  navigate?: (path: string) => void;\n  /** Function to execute another action */\n  executeAction?: (name: string) => Promise<void>;\n}\n\n/**\n * Execute an action with all callbacks\n */\nexport async function executeAction(\n  ctx: ActionExecutionContext,\n): Promise<void> {\n  const { action, handler, setState, navigate, executeAction } = ctx;\n\n  try {\n    await handler(action.params);\n\n    // Handle success\n    if (action.onSuccess) {\n      if (\"navigate\" in action.onSuccess && navigate) {\n        navigate(action.onSuccess.navigate);\n      } else if (\"set\" in action.onSuccess) {\n        for (const [path, value] of Object.entries(action.onSuccess.set)) {\n          setState(path, value);\n        }\n      } else if (\"action\" in action.onSuccess && executeAction) {\n        await executeAction(action.onSuccess.action);\n      }\n    }\n  } catch (error) {\n    // Handle error\n    if (action.onError) {\n      if (\"set\" in action.onError) {\n        for (const [path, value] of Object.entries(action.onError.set)) {\n          // Replace $error.message with actual error\n          const resolvedValue =\n            typeof value === \"string\" && value === \"$error.message\"\n              ? (error as Error).message\n              : value;\n          setState(path, resolvedValue);\n        }\n      } else if (\"action\" in action.onError && executeAction) {\n        await executeAction(action.onError.action);\n      }\n    } else {\n      throw error;\n    }\n  }\n}\n\n/**\n * Helper to create action bindings\n */\nexport const actionBinding = {\n  /** Create a simple action binding */\n  simple: (\n    actionName: string,\n    params?: Record<string, DynamicValue>,\n  ): ActionBinding => ({\n    action: actionName,\n    params,\n  }),\n\n  /** Create an action binding with confirmation */\n  withConfirm: (\n    actionName: string,\n    confirm: ActionConfirm,\n    params?: Record<string, DynamicValue>,\n  ): ActionBinding => ({\n    action: actionName,\n    params,\n    confirm,\n  }),\n\n  /** Create an action binding with success handler */\n  withSuccess: (\n    actionName: string,\n    onSuccess: ActionOnSuccess,\n    params?: Record<string, DynamicValue>,\n  ): ActionBinding => ({\n    action: actionName,\n    params,\n    onSuccess,\n  }),\n};\n\n/**\n * @deprecated Use actionBinding instead\n */\nexport const action = actionBinding;\n","import { z } from \"zod\";\nimport type { DynamicValue, StateModel, VisibilityCondition } from \"./types\";\nimport { DynamicValueSchema, resolveDynamicValue } from \"./types\";\nimport { VisibilityConditionSchema, evaluateVisibility } from \"./visibility\";\n\n/**\n * Validation check definition\n */\nexport interface ValidationCheck {\n  /** Validation type (built-in or from catalog) */\n  type: string;\n  /** Additional arguments for the validation */\n  args?: Record<string, DynamicValue>;\n  /** Error message to display if check fails */\n  message: string;\n}\n\n/**\n * Validation configuration for a field\n */\nexport interface ValidationConfig {\n  /** Array of checks to run */\n  checks?: ValidationCheck[];\n  /** When to run validation */\n  validateOn?: \"change\" | \"blur\" | \"submit\";\n  /** Condition for when validation is enabled */\n  enabled?: VisibilityCondition;\n}\n\n/**\n * Schema for validation check\n */\nexport const ValidationCheckSchema = z.object({\n  type: z.string(),\n  args: z.record(z.string(), DynamicValueSchema).optional(),\n  message: z.string(),\n});\n\n/**\n * Schema for validation config\n */\nexport const ValidationConfigSchema = z.object({\n  checks: z.array(ValidationCheckSchema).optional(),\n  validateOn: z.enum([\"change\", \"blur\", \"submit\"]).optional(),\n  enabled: VisibilityConditionSchema.optional(),\n});\n\n/**\n * Validation function signature\n */\nexport type ValidationFunction = (\n  value: unknown,\n  args?: Record<string, unknown>,\n) => boolean;\n\n/**\n * Validation function definition in catalog\n */\nexport interface ValidationFunctionDefinition {\n  /** The validation function */\n  validate: ValidationFunction;\n  /** Description for AI */\n  description?: string;\n}\n\n/**\n * Built-in validation functions\n */\nexport const builtInValidationFunctions: Record<string, ValidationFunction> = {\n  /**\n   * Check if value is not null, undefined, or empty string\n   */\n  required: (value: unknown) => {\n    if (value === null || value === undefined) return false;\n    if (typeof value === \"string\") return value.trim().length > 0;\n    if (Array.isArray(value)) return value.length > 0;\n    return true;\n  },\n\n  /**\n   * Check if value is a valid email address\n   */\n  email: (value: unknown) => {\n    if (typeof value !== \"string\") return false;\n    return /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/.test(value);\n  },\n\n  /**\n   * Check minimum string length\n   */\n  minLength: (value: unknown, args?: Record<string, unknown>) => {\n    if (typeof value !== \"string\") return false;\n    const min = args?.min;\n    if (typeof min !== \"number\") return false;\n    return value.length >= min;\n  },\n\n  /**\n   * Check maximum string length\n   */\n  maxLength: (value: unknown, args?: Record<string, unknown>) => {\n    if (typeof value !== \"string\") return false;\n    const max = args?.max;\n    if (typeof max !== \"number\") return false;\n    return value.length <= max;\n  },\n\n  /**\n   * Check if string matches a regex pattern\n   */\n  pattern: (value: unknown, args?: Record<string, unknown>) => {\n    if (typeof value !== \"string\") return false;\n    const pattern = args?.pattern;\n    if (typeof pattern !== \"string\") return false;\n    try {\n      return new RegExp(pattern).test(value);\n    } catch {\n      return false;\n    }\n  },\n\n  /**\n   * Check minimum numeric value\n   */\n  min: (value: unknown, args?: Record<string, unknown>) => {\n    if (typeof value !== \"number\") return false;\n    const min = args?.min;\n    if (typeof min !== \"number\") return false;\n    return value >= min;\n  },\n\n  /**\n   * Check maximum numeric value\n   */\n  max: (value: unknown, args?: Record<string, unknown>) => {\n    if (typeof value !== \"number\") return false;\n    const max = args?.max;\n    if (typeof max !== \"number\") return false;\n    return value <= max;\n  },\n\n  /**\n   * Check if value is a number\n   */\n  numeric: (value: unknown) => {\n    if (typeof value === \"number\") return !isNaN(value);\n    if (typeof value === \"string\") return !isNaN(parseFloat(value));\n    return false;\n  },\n\n  /**\n   * Check if value is a valid URL\n   */\n  url: (value: unknown) => {\n    if (typeof value !== \"string\") return false;\n    try {\n      new URL(value);\n      return true;\n    } catch {\n      return false;\n    }\n  },\n\n  /**\n   * Check if value matches another field\n   */\n  matches: (value: unknown, args?: Record<string, unknown>) => {\n    const other = args?.other;\n    return value === other;\n  },\n};\n\n/**\n * Validation result for a single check\n */\nexport interface ValidationCheckResult {\n  type: string;\n  valid: boolean;\n  message: string;\n}\n\n/**\n * Full validation result for a field\n */\nexport interface ValidationResult {\n  valid: boolean;\n  errors: string[];\n  checks: ValidationCheckResult[];\n}\n\n/**\n * Context for running validation\n */\nexport interface ValidationContext {\n  /** Current value to validate */\n  value: unknown;\n  /** Full data model for resolving paths */\n  stateModel: StateModel;\n  /** Custom validation functions from catalog */\n  customFunctions?: Record<string, ValidationFunction>;\n}\n\n/**\n * Run a single validation check\n */\nexport function runValidationCheck(\n  check: ValidationCheck,\n  ctx: ValidationContext,\n): ValidationCheckResult {\n  const { value, stateModel, customFunctions } = ctx;\n\n  // Resolve args\n  const resolvedArgs: Record<string, unknown> = {};\n  if (check.args) {\n    for (const [key, argValue] of Object.entries(check.args)) {\n      resolvedArgs[key] = resolveDynamicValue(argValue, stateModel);\n    }\n  }\n\n  // Find the validation function\n  const validationFn =\n    builtInValidationFunctions[check.type] ?? customFunctions?.[check.type];\n\n  if (!validationFn) {\n    console.warn(`Unknown validation function: ${check.type}`);\n    return {\n      type: check.type,\n      valid: true, // Don't fail on unknown functions\n      message: check.message,\n    };\n  }\n\n  const valid = validationFn(value, resolvedArgs);\n\n  return {\n    type: check.type,\n    valid,\n    message: check.message,\n  };\n}\n\n/**\n * Run all validation checks for a field\n */\nexport function runValidation(\n  config: ValidationConfig,\n  ctx: ValidationContext,\n): ValidationResult {\n  const checks: ValidationCheckResult[] = [];\n  const errors: string[] = [];\n\n  // Check if validation is enabled\n  if (config.enabled) {\n    const enabled = evaluateVisibility(config.enabled, {\n      stateModel: ctx.stateModel,\n    });\n    if (!enabled) {\n      return { valid: true, errors: [], checks: [] };\n    }\n  }\n\n  // Run each check\n  if (config.checks) {\n    for (const check of config.checks) {\n      const result = runValidationCheck(check, ctx);\n      checks.push(result);\n      if (!result.valid) {\n        errors.push(result.message);\n      }\n    }\n  }\n\n  return {\n    valid: errors.length === 0,\n    errors,\n    checks,\n  };\n}\n\n/**\n * Helper to create validation checks\n */\nexport const check = {\n  required: (message = \"This field is required\"): ValidationCheck => ({\n    type: \"required\",\n    message,\n  }),\n\n  email: (message = \"Invalid email address\"): ValidationCheck => ({\n    type: \"email\",\n    message,\n  }),\n\n  minLength: (min: number, message?: string): ValidationCheck => ({\n    type: \"minLength\",\n    args: { min },\n    message: message ?? `Must be at least ${min} characters`,\n  }),\n\n  maxLength: (max: number, message?: string): ValidationCheck => ({\n    type: \"maxLength\",\n    args: { max },\n    message: message ?? `Must be at most ${max} characters`,\n  }),\n\n  pattern: (pattern: string, message = \"Invalid format\"): ValidationCheck => ({\n    type: \"pattern\",\n    args: { pattern },\n    message,\n  }),\n\n  min: (min: number, message?: string): ValidationCheck => ({\n    type: \"min\",\n    args: { min },\n    message: message ?? `Must be at least ${min}`,\n  }),\n\n  max: (max: number, message?: string): ValidationCheck => ({\n    type: \"max\",\n    args: { max },\n    message: message ?? `Must be at most ${max}`,\n  }),\n\n  url: (message = \"Invalid URL\"): ValidationCheck => ({\n    type: \"url\",\n    message,\n  }),\n\n  matches: (\n    otherPath: string,\n    message = \"Fields must match\",\n  ): ValidationCheck => ({\n    type: \"matches\",\n    args: { other: { $state: otherPath } },\n    message,\n  }),\n};\n","import type { Spec, UIElement } from \"./types\";\n\n// =============================================================================\n// Spec Structural Validation\n// =============================================================================\n\n/**\n * Severity level for validation issues.\n */\nexport type SpecIssueSeverity = \"error\" | \"warning\";\n\n/**\n * A single validation issue found in a spec.\n */\nexport interface SpecIssue {\n  /** Severity: errors should be fixed, warnings are informational */\n  severity: SpecIssueSeverity;\n  /** Human-readable description of the issue */\n  message: string;\n  /** The element key where the issue was found (if applicable) */\n  elementKey?: string;\n  /** Machine-readable issue code for programmatic handling */\n  code:\n    | \"missing_root\"\n    | \"root_not_found\"\n    | \"missing_child\"\n    | \"visible_in_props\"\n    | \"orphaned_element\"\n    | \"empty_spec\"\n    | \"on_in_props\"\n    | \"repeat_in_props\";\n}\n\n/**\n * Result of spec structural validation.\n */\nexport interface SpecValidationIssues {\n  /** Whether the spec passed validation (no errors; warnings are OK) */\n  valid: boolean;\n  /** List of issues found */\n  issues: SpecIssue[];\n}\n\n/**\n * Options for validateSpec.\n */\nexport interface ValidateSpecOptions {\n  /**\n   * Whether to check for orphaned elements (elements not reachable from root).\n   * Defaults to false since orphans are harmless (just unused).\n   */\n  checkOrphans?: boolean;\n}\n\n/**\n * Validate a spec for structural integrity.\n *\n * Checks for common AI-generation errors:\n * - Missing or empty root\n * - Root element not found in elements map\n * - Children referencing non-existent elements\n * - `visible` placed inside `props` instead of on the element\n * - Orphaned elements (optional)\n *\n * @example\n * ```ts\n * const result = validateSpec(spec);\n * if (!result.valid) {\n *   console.log(\"Spec errors:\", result.issues);\n * }\n * ```\n */\nexport function validateSpec(\n  spec: Spec,\n  options: ValidateSpecOptions = {},\n): SpecValidationIssues {\n  const { checkOrphans = false } = options;\n  const issues: SpecIssue[] = [];\n\n  // 1. Check root\n  if (!spec.root) {\n    issues.push({\n      severity: \"error\",\n      message: \"Spec has no root element defined.\",\n      code: \"missing_root\",\n    });\n    return { valid: false, issues };\n  }\n\n  if (!spec.elements[spec.root]) {\n    issues.push({\n      severity: \"error\",\n      message: `Root element \"${spec.root}\" not found in elements map.`,\n      code: \"root_not_found\",\n    });\n  }\n\n  // 2. Check for empty spec\n  if (Object.keys(spec.elements).length === 0) {\n    issues.push({\n      severity: \"error\",\n      message: \"Spec has no elements.\",\n      code: \"empty_spec\",\n    });\n    return { valid: false, issues };\n  }\n\n  // 3. Check each element\n  for (const [key, element] of Object.entries(spec.elements)) {\n    // 3a. Missing children\n    if (element.children) {\n      for (const childKey of element.children) {\n        if (!spec.elements[childKey]) {\n          issues.push({\n            severity: \"error\",\n            message: `Element \"${key}\" references child \"${childKey}\" which does not exist in the elements map.`,\n            elementKey: key,\n            code: \"missing_child\",\n          });\n        }\n      }\n    }\n\n    // 3b. `visible` inside props\n    const props = element.props as Record<string, unknown> | undefined;\n    if (props && \"visible\" in props && props.visible !== undefined) {\n      issues.push({\n        severity: \"error\",\n        message: `Element \"${key}\" has \"visible\" inside \"props\". It should be a top-level field on the element (sibling of type/props/children).`,\n        elementKey: key,\n        code: \"visible_in_props\",\n      });\n    }\n\n    // 3c. `on` inside props (should be a top-level field)\n    if (props && \"on\" in props && props.on !== undefined) {\n      issues.push({\n        severity: \"error\",\n        message: `Element \"${key}\" has \"on\" inside \"props\". It should be a top-level field on the element (sibling of type/props/children).`,\n        elementKey: key,\n        code: \"on_in_props\",\n      });\n    }\n\n    // 3d. `repeat` inside props (should be a top-level field)\n    if (props && \"repeat\" in props && props.repeat !== undefined) {\n      issues.push({\n        severity: \"error\",\n        message: `Element \"${key}\" has \"repeat\" inside \"props\". It should be a top-level field on the element (sibling of type/props/children).`,\n        elementKey: key,\n        code: \"repeat_in_props\",\n      });\n    }\n  }\n\n  // 4. Orphaned elements (optional)\n  if (checkOrphans) {\n    const reachable = new Set<string>();\n    const walk = (key: string) => {\n      if (reachable.has(key)) return;\n      reachable.add(key);\n      const el = spec.elements[key];\n      if (el?.children) {\n        for (const childKey of el.children) {\n          if (spec.elements[childKey]) {\n            walk(childKey);\n          }\n        }\n      }\n    };\n    if (spec.elements[spec.root]) {\n      walk(spec.root);\n    }\n\n    for (const key of Object.keys(spec.elements)) {\n      if (!reachable.has(key)) {\n        issues.push({\n          severity: \"warning\",\n          message: `Element \"${key}\" is not reachable from root \"${spec.root}\".`,\n          elementKey: key,\n          code: \"orphaned_element\",\n        });\n      }\n    }\n  }\n\n  const hasErrors = issues.some((i) => i.severity === \"error\");\n  return { valid: !hasErrors, issues };\n}\n\n/**\n * Auto-fix common spec issues in-place and return a corrected copy.\n *\n * Currently fixes:\n * - `visible` inside `props` → moved to element level\n * - `on` inside `props` → moved to element level\n * - `repeat` inside `props` → moved to element level\n *\n * Returns the fixed spec and a list of fixes applied.\n */\nexport function autoFixSpec(spec: Spec): {\n  spec: Spec;\n  fixes: string[];\n} {\n  const fixes: string[] = [];\n  const fixedElements: Record<string, UIElement> = {};\n\n  for (const [key, element] of Object.entries(spec.elements)) {\n    const props = element.props as Record<string, unknown> | undefined;\n    let fixed = element;\n\n    if (props && \"visible\" in props && props.visible !== undefined) {\n      // Move visible from props to element level\n      const { visible, ...restProps } = fixed.props as Record<string, unknown>;\n      fixed = {\n        ...fixed,\n        props: restProps,\n        visible: visible as UIElement[\"visible\"],\n      };\n      fixes.push(`Moved \"visible\" from props to element level on \"${key}\".`);\n    }\n\n    let currentProps = fixed.props as Record<string, unknown> | undefined;\n    if (currentProps && \"on\" in currentProps && currentProps.on !== undefined) {\n      // Move on from props to element level\n      const { on, ...restProps } = currentProps;\n      fixed = {\n        ...fixed,\n        props: restProps,\n        on: on as UIElement[\"on\"],\n      };\n      fixes.push(`Moved \"on\" from props to element level on \"${key}\".`);\n    }\n\n    currentProps = fixed.props as Record<string, unknown> | undefined;\n    if (\n      currentProps &&\n      \"repeat\" in currentProps &&\n      currentProps.repeat !== undefined\n    ) {\n      // Move repeat from props to element level\n      const { repeat, ...restProps } = currentProps;\n      fixed = {\n        ...fixed,\n        props: restProps,\n        repeat: repeat as UIElement[\"repeat\"],\n      };\n      fixes.push(`Moved \"repeat\" from props to element level on \"${key}\".`);\n    }\n\n    fixedElements[key] = fixed;\n  }\n\n  return {\n    spec: { root: spec.root, elements: fixedElements, state: spec.state },\n    fixes,\n  };\n}\n\n/**\n * Format validation issues into a human-readable string suitable for\n * inclusion in a repair prompt sent back to the AI.\n */\nexport function formatSpecIssues(issues: SpecIssue[]): string {\n  const errors = issues.filter((i) => i.severity === \"error\");\n  if (errors.length === 0) return \"\";\n\n  const lines = [\"The generated UI spec has the following errors:\"];\n  for (const issue of errors) {\n    lines.push(`- ${issue.message}`);\n  }\n  return lines.join(\"\\n\");\n}\n","import { z } from \"zod\";\n\n/**\n * Schema builder primitives\n */\nexport interface SchemaBuilder {\n  /** String type */\n  string(): SchemaType<\"string\">;\n  /** Number type */\n  number(): SchemaType<\"number\">;\n  /** Boolean type */\n  boolean(): SchemaType<\"boolean\">;\n  /** Array of type */\n  array<T extends SchemaType>(item: T): SchemaType<\"array\", T>;\n  /** Object with shape */\n  object<T extends Record<string, SchemaType>>(\n    shape: T,\n  ): SchemaType<\"object\", T>;\n  /** Record/map with value type */\n  record<T extends SchemaType>(value: T): SchemaType<\"record\", T>;\n  /** Any type */\n  any(): SchemaType<\"any\">;\n  /** Placeholder for user-provided Zod schema */\n  zod(): SchemaType<\"zod\">;\n  /** Reference to catalog key (e.g., 'catalog.components') */\n  ref(path: string): SchemaType<\"ref\", string>;\n  /** Props from referenced catalog entry */\n  propsOf(path: string): SchemaType<\"propsOf\", string>;\n  /** Map of named entries with shared shape */\n  map<T extends Record<string, SchemaType>>(\n    entryShape: T,\n  ): SchemaType<\"map\", T>;\n  /** Optional modifier */\n  optional(): { optional: true };\n}\n\n/**\n * Schema type representation\n */\nexport interface SchemaType<TKind extends string = string, TInner = unknown> {\n  kind: TKind;\n  inner?: TInner;\n  optional?: boolean;\n}\n\n/**\n * Schema definition shape\n */\nexport interface SchemaDefinition<\n  TSpec extends SchemaType = SchemaType,\n  TCatalog extends SchemaType = SchemaType,\n> {\n  /** What the AI-generated spec looks like */\n  spec: TSpec;\n  /** What the catalog must provide */\n  catalog: TCatalog;\n}\n\n/**\n * Schema instance with methods\n */\nexport interface Schema<TDef extends SchemaDefinition = SchemaDefinition> {\n  /** The schema definition */\n  readonly definition: TDef;\n  /** Custom prompt template for this schema */\n  readonly promptTemplate?: PromptTemplate;\n  /** Default rules baked into the schema (injected before customRules) */\n  readonly defaultRules?: string[];\n  /** Create a catalog from this schema */\n  createCatalog<TCatalog extends InferCatalogInput<TDef[\"catalog\"]>>(\n    catalog: TCatalog,\n  ): Catalog<TDef, TCatalog>;\n}\n\n/**\n * Catalog instance with methods\n */\nexport interface Catalog<\n  TDef extends SchemaDefinition = SchemaDefinition,\n  TCatalog = unknown,\n> {\n  /** The schema this catalog is based on */\n  readonly schema: Schema<TDef>;\n  /** The catalog data */\n  readonly data: TCatalog;\n  /** Component names */\n  readonly componentNames: string[];\n  /** Action names */\n  readonly actionNames: string[];\n  /** Generate system prompt for AI */\n  prompt(options?: PromptOptions): string;\n  /** Export as JSON Schema for structured outputs */\n  jsonSchema(): object;\n  /** Validate a spec against this catalog */\n  validate(spec: unknown): SpecValidationResult<InferSpec<TDef, TCatalog>>;\n  /** Get the Zod schema for the spec */\n  zodSchema(): z.ZodType<InferSpec<TDef, TCatalog>>;\n  /** Type helper for the spec type */\n  readonly _specType: InferSpec<TDef, TCatalog>;\n}\n\n/**\n * Prompt generation options\n */\nexport interface PromptOptions {\n  /** Custom system message intro */\n  system?: string;\n  /** Additional rules to append */\n  customRules?: string[];\n  /**\n   * Output mode for the generated prompt.\n   *\n   * - `\"generate\"` (default): The LLM should output only JSONL patches (no prose).\n   * - `\"chat\"`: The LLM should respond conversationally first, then output JSONL patches.\n   *   Includes rules about interleaving text with JSONL and not wrapping in code fences.\n   */\n  mode?: \"generate\" | \"chat\";\n}\n\n/**\n * Context provided to prompt templates\n */\nexport interface PromptContext<TCatalog = unknown> {\n  /** The catalog data */\n  catalog: TCatalog;\n  /** Component names from the catalog */\n  componentNames: string[];\n  /** Action names from the catalog (if any) */\n  actionNames: string[];\n  /** Prompt options provided by the user */\n  options: PromptOptions;\n  /** Helper to format a Zod type as a human-readable string */\n  formatZodType: (schema: z.ZodType) => string;\n}\n\n/**\n * Prompt template function type\n */\nexport type PromptTemplate<TCatalog = unknown> = (\n  context: PromptContext<TCatalog>,\n) => string;\n\n/**\n * Schema options\n */\nexport interface SchemaOptions<TCatalog = unknown> {\n  /** Custom prompt template for this schema */\n  promptTemplate?: PromptTemplate<TCatalog>;\n  /** Default rules baked into the schema (injected before customRules in prompts) */\n  defaultRules?: string[];\n}\n\n/**\n * Spec validation result\n */\nexport interface SpecValidationResult<T> {\n  success: boolean;\n  data?: T;\n  error?: z.ZodError;\n}\n\n// =============================================================================\n// Catalog Type Inference Helpers\n// =============================================================================\n\n/**\n * Extract the components map type from a catalog\n * @example type Components = InferCatalogComponents<typeof myCatalog>;\n */\nexport type InferCatalogComponents<C extends Catalog> =\n  C extends Catalog<SchemaDefinition, infer TCatalog>\n    ? TCatalog extends { components: infer Comps }\n      ? Comps\n      : never\n    : never;\n\n/**\n * Extract the actions map type from a catalog\n * @example type Actions = InferCatalogActions<typeof myCatalog>;\n */\nexport type InferCatalogActions<C extends Catalog> =\n  C extends Catalog<SchemaDefinition, infer TCatalog>\n    ? TCatalog extends { actions: infer Acts }\n      ? Acts\n      : never\n    : never;\n\n/**\n * Infer component props from a catalog by component name\n * @example type ButtonProps = InferComponentProps<typeof myCatalog, 'Button'>;\n */\nexport type InferComponentProps<\n  C extends Catalog,\n  K extends keyof InferCatalogComponents<C>,\n> = InferCatalogComponents<C>[K] extends { props: z.ZodType<infer P> }\n  ? P\n  : never;\n\n/**\n * Infer action params from a catalog by action name\n * @example type ViewCustomersParams = InferActionParams<typeof myCatalog, 'viewCustomers'>;\n */\nexport type InferActionParams<\n  C extends Catalog,\n  K extends keyof InferCatalogActions<C>,\n> = InferCatalogActions<C>[K] extends { params: z.ZodType<infer P> }\n  ? P\n  : never;\n\n// =============================================================================\n// Internal Type Inference Helpers\n// =============================================================================\n\nexport type InferCatalogInput<T> =\n  T extends SchemaType<\"object\", infer Shape>\n    ? { [K in keyof Shape]: InferCatalogField<Shape[K]> }\n    : never;\n\ntype InferCatalogField<T> =\n  T extends SchemaType<\"map\", infer EntryShape>\n    ? Record<\n        string,\n        // Only 'props' is required, rest are optional\n        InferMapEntryRequired<EntryShape> &\n          Partial<InferMapEntryOptional<EntryShape>>\n      >\n    : T extends SchemaType<\"zod\">\n      ? z.ZodType\n      : T extends SchemaType<\"string\">\n        ? string\n        : T extends SchemaType<\"number\">\n          ? number\n          : T extends SchemaType<\"boolean\">\n            ? boolean\n            : T extends SchemaType<\"array\", infer Item>\n              ? InferCatalogField<Item>[]\n              : T extends SchemaType<\"object\", infer Shape>\n                ? { [K in keyof Shape]: InferCatalogField<Shape[K]> }\n                : unknown;\n\n// Extract required fields (props is always required)\ntype InferMapEntryRequired<T> = {\n  [K in keyof T as K extends \"props\" ? K : never]: InferMapEntryField<T[K]>;\n};\n\n// Extract optional fields (everything except props)\ntype InferMapEntryOptional<T> = {\n  [K in keyof T as K extends \"props\" ? never : K]: InferMapEntryField<T[K]>;\n};\n\ntype InferMapEntryField<T> =\n  T extends SchemaType<\"zod\">\n    ? z.ZodType\n    : T extends SchemaType<\"string\">\n      ? string\n      : T extends SchemaType<\"number\">\n        ? number\n        : T extends SchemaType<\"boolean\">\n          ? boolean\n          : T extends SchemaType<\"array\", infer Item>\n            ? InferMapEntryField<Item>[]\n            : T extends SchemaType<\"object\", infer Shape>\n              ? { [K in keyof Shape]: InferMapEntryField<Shape[K]> }\n              : unknown;\n\n// Spec inference (simplified - will be expanded)\nexport type InferSpec<TDef extends SchemaDefinition, TCatalog> = TDef extends {\n  spec: SchemaType<\"object\", infer Shape>;\n}\n  ? InferSpecObject<Shape, TCatalog>\n  : unknown;\n\ntype InferSpecObject<Shape, TCatalog> = {\n  [K in keyof Shape]: InferSpecField<Shape[K], TCatalog>;\n};\n\ntype InferSpecField<T, TCatalog> =\n  T extends SchemaType<\"string\">\n    ? string\n    : T extends SchemaType<\"number\">\n      ? number\n      : T extends SchemaType<\"boolean\">\n        ? boolean\n        : T extends SchemaType<\"array\", infer Item>\n          ? InferSpecField<Item, TCatalog>[]\n          : T extends SchemaType<\"object\", infer Shape>\n            ? InferSpecObject<Shape, TCatalog>\n            : T extends SchemaType<\"record\", infer Value>\n              ? Record<string, InferSpecField<Value, TCatalog>>\n              : T extends SchemaType<\"ref\", infer Path>\n                ? InferRefType<Path, TCatalog>\n                : T extends SchemaType<\"propsOf\", infer Path>\n                  ? InferPropsOfType<Path, TCatalog>\n                  : T extends SchemaType<\"any\">\n                    ? unknown\n                    : unknown;\n\ntype InferRefType<Path, TCatalog> = Path extends \"catalog.components\"\n  ? TCatalog extends { components: infer C }\n    ? keyof C\n    : string\n  : Path extends \"catalog.actions\"\n    ? TCatalog extends { actions: infer A }\n      ? keyof A\n      : string\n    : string;\n\ntype InferPropsOfType<Path, TCatalog> = Path extends \"catalog.components\"\n  ? TCatalog extends { components: infer C }\n    ? C extends Record<string, { props: z.ZodType<infer P> }>\n      ? P\n      : Record<string, unknown>\n    : Record<string, unknown>\n  : Record<string, unknown>;\n\n/**\n * Create the schema builder\n */\nfunction createBuilder(): SchemaBuilder {\n  return {\n    string: () => ({ kind: \"string\" }),\n    number: () => ({ kind: \"number\" }),\n    boolean: () => ({ kind: \"boolean\" }),\n    array: (item) => ({ kind: \"array\", inner: item }),\n    object: (shape) => ({ kind: \"object\", inner: shape }),\n    record: (value) => ({ kind: \"record\", inner: value }),\n    any: () => ({ kind: \"any\" }),\n    zod: () => ({ kind: \"zod\" }),\n    ref: (path) => ({ kind: \"ref\", inner: path }),\n    propsOf: (path) => ({ kind: \"propsOf\", inner: path }),\n    map: (entryShape) => ({ kind: \"map\", inner: entryShape }),\n    optional: () => ({ optional: true }),\n  };\n}\n\n/**\n * Define a schema using the builder pattern\n */\nexport function defineSchema<TDef extends SchemaDefinition>(\n  builder: (s: SchemaBuilder) => TDef,\n  options?: SchemaOptions,\n): Schema<TDef> {\n  const s = createBuilder();\n  const definition = builder(s);\n\n  return {\n    definition,\n    promptTemplate: options?.promptTemplate,\n    defaultRules: options?.defaultRules,\n    createCatalog<TCatalog extends InferCatalogInput<TDef[\"catalog\"]>>(\n      catalog: TCatalog,\n    ): Catalog<TDef, TCatalog> {\n      return createCatalogFromSchema(this as Schema<TDef>, catalog);\n    },\n  };\n}\n\n/**\n * Create a catalog from a schema (internal)\n */\nfunction createCatalogFromSchema<TDef extends SchemaDefinition, TCatalog>(\n  schema: Schema<TDef>,\n  catalogData: TCatalog,\n): Catalog<TDef, TCatalog> {\n  // Extract component and action names\n  const components = (catalogData as Record<string, unknown>).components as\n    | Record<string, unknown>\n    | undefined;\n  const actions = (catalogData as Record<string, unknown>).actions as\n    | Record<string, unknown>\n    | undefined;\n\n  const componentNames = components ? Object.keys(components) : [];\n  const actionNames = actions ? Object.keys(actions) : [];\n\n  // Build the Zod schema for validation\n  const zodSchema = buildZodSchemaFromDefinition(\n    schema.definition,\n    catalogData,\n  );\n\n  return {\n    schema,\n    data: catalogData,\n    componentNames,\n    actionNames,\n\n    prompt(options: PromptOptions = {}): string {\n      return generatePrompt(this, options);\n    },\n\n    jsonSchema(): object {\n      return zodToJsonSchema(zodSchema);\n    },\n\n    validate(spec: unknown): SpecValidationResult<InferSpec<TDef, TCatalog>> {\n      const result = zodSchema.safeParse(spec);\n      if (result.success) {\n        return {\n          success: true,\n          data: result.data as InferSpec<TDef, TCatalog>,\n        };\n      }\n      return { success: false, error: result.error };\n    },\n\n    zodSchema(): z.ZodType<InferSpec<TDef, TCatalog>> {\n      return zodSchema as z.ZodType<InferSpec<TDef, TCatalog>>;\n    },\n\n    get _specType(): InferSpec<TDef, TCatalog> {\n      throw new Error(\"_specType is only for type inference\");\n    },\n  };\n}\n\n/**\n * Build Zod schema from schema definition\n */\nfunction buildZodSchemaFromDefinition(\n  definition: SchemaDefinition,\n  catalogData: unknown,\n): z.ZodType {\n  return buildZodType(definition.spec, catalogData);\n}\n\nfunction buildZodType(schemaType: SchemaType, catalogData: unknown): z.ZodType {\n  switch (schemaType.kind) {\n    case \"string\":\n      return z.string();\n    case \"number\":\n      return z.number();\n    case \"boolean\":\n      return z.boolean();\n    case \"any\":\n      return z.any();\n    case \"array\": {\n      const inner = buildZodType(schemaType.inner as SchemaType, catalogData);\n      return z.array(inner);\n    }\n    case \"object\": {\n      const shape = schemaType.inner as Record<string, SchemaType>;\n      const zodShape: Record<string, z.ZodType> = {};\n      for (const [key, value] of Object.entries(shape)) {\n        let zodType = buildZodType(value, catalogData);\n        if (value.optional) {\n          zodType = zodType.optional();\n        }\n        zodShape[key] = zodType;\n      }\n      return z.object(zodShape);\n    }\n    case \"record\": {\n      const inner = buildZodType(schemaType.inner as SchemaType, catalogData);\n      return z.record(z.string(), inner);\n    }\n    case \"ref\": {\n      // Reference to catalog key - create enum of valid keys\n      const path = schemaType.inner as string;\n      const keys = getKeysFromPath(path, catalogData);\n      if (keys.length === 0) {\n        return z.string();\n      }\n      if (keys.length === 1) {\n        return z.literal(keys[0]!);\n      }\n      return z.enum(keys as [string, ...string[]]);\n    }\n    case \"propsOf\": {\n      // Props from catalog entry - create union of all props schemas\n      const path = schemaType.inner as string;\n      const propsSchemas = getPropsFromPath(path, catalogData);\n      if (propsSchemas.length === 0) {\n        return z.record(z.string(), z.unknown());\n      }\n      if (propsSchemas.length === 1) {\n        return propsSchemas[0]!;\n      }\n      // For propsOf, we need to be lenient since type determines which props apply\n      return z.record(z.string(), z.unknown());\n    }\n    default:\n      return z.unknown();\n  }\n}\n\nfunction getKeysFromPath(path: string, catalogData: unknown): string[] {\n  const parts = path.split(\".\");\n  let current: unknown = { catalog: catalogData };\n  for (const part of parts) {\n    if (current && typeof current === \"object\") {\n      current = (current as Record<string, unknown>)[part];\n    } else {\n      return [];\n    }\n  }\n  if (current && typeof current === \"object\") {\n    return Object.keys(current);\n  }\n  return [];\n}\n\nfunction getPropsFromPath(path: string, catalogData: unknown): z.ZodType[] {\n  const parts = path.split(\".\");\n  let current: unknown = { catalog: catalogData };\n  for (const part of parts) {\n    if (current && typeof current === \"object\") {\n      current = (current as Record<string, unknown>)[part];\n    } else {\n      return [];\n    }\n  }\n  if (current && typeof current === \"object\") {\n    return Object.values(current as Record<string, { props?: z.ZodType }>)\n      .map((entry) => entry.props)\n      .filter((props): props is z.ZodType => props !== undefined);\n  }\n  return [];\n}\n\n/**\n * Generate system prompt from catalog\n */\nfunction generatePrompt<TDef extends SchemaDefinition, TCatalog>(\n  catalog: Catalog<TDef, TCatalog>,\n  options: PromptOptions,\n): string {\n  // Check if schema has a custom prompt template\n  if (catalog.schema.promptTemplate) {\n    const context: PromptContext<TCatalog> = {\n      catalog: catalog.data,\n      componentNames: catalog.componentNames,\n      actionNames: catalog.actionNames,\n      options,\n      formatZodType,\n    };\n    return catalog.schema.promptTemplate(context);\n  }\n\n  // Default JSONL element-tree format (for @json-render/react and similar)\n  const {\n    system = \"You are a UI generator that outputs JSON.\",\n    customRules = [],\n    mode = \"generate\",\n  } = options;\n\n  const lines: string[] = [];\n  lines.push(system);\n  lines.push(\"\");\n\n  // Output format section - explain JSONL streaming patch format\n  if (mode === \"chat\") {\n    lines.push(\"OUTPUT FORMAT (text + JSONL, RFC 6902 JSON Patch):\");\n    lines.push(\n      \"You respond conversationally. When generating UI, first write a brief explanation (1-3 sentences), then output JSONL patch lines wrapped in a ```spec code fence.\",\n    );\n    lines.push(\n      \"The JSONL lines use RFC 6902 JSON Patch operations to build a UI tree. Always wrap them in a ```spec fence block:\",\n    );\n    lines.push(\"  ```spec\");\n    lines.push('  {\"op\":\"add\",\"path\":\"/root\",\"value\":\"main\"}');\n    lines.push(\n      '  {\"op\":\"add\",\"path\":\"/elements/main\",\"value\":{\"type\":\"Card\",\"props\":{\"title\":\"Hello\"},\"children\":[]}}',\n    );\n    lines.push(\"  ```\");\n    lines.push(\n      \"If the user's message does not require a UI (e.g. a greeting or clarifying question), respond with text only — no JSONL.\",\n    );\n  } else {\n    lines.push(\"OUTPUT FORMAT (JSONL, RFC 6902 JSON Patch):\");\n    lines.push(\n      \"Output JSONL (one JSON object per line) using RFC 6902 JSON Patch operations to build a UI tree.\",\n    );\n  }\n  lines.push(\n    \"Each line is a JSON patch operation (add, remove, replace). Start with /root, then stream /elements and /state patches interleaved so the UI fills in progressively as it streams.\",\n  );\n  lines.push(\"\");\n  lines.push(\"Example output (each line is a separate JSON object):\");\n  lines.push(\"\");\n\n  // Build example using actual catalog component names and props to avoid hallucinations\n  const allComponents = (catalog.data as Record<string, unknown>).components as\n    | Record<string, CatalogComponentDef>\n    | undefined;\n  const cn = catalog.componentNames;\n  const comp1 = cn[0] || \"Component\";\n  const comp2 = cn.length > 1 ? cn[1]! : comp1;\n  const comp1Def = allComponents?.[comp1];\n  const comp2Def = allComponents?.[comp2];\n  const comp1Props = comp1Def ? getExampleProps(comp1Def) : {};\n  const comp2Props = comp2Def ? getExampleProps(comp2Def) : {};\n\n  // Find a string prop on comp2 to demonstrate $state dynamic bindings\n  const dynamicPropName = comp2Def?.props\n    ? findFirstStringProp(comp2Def.props)\n    : null;\n  const dynamicProps = dynamicPropName\n    ? { ...comp2Props, [dynamicPropName]: { $item: \"title\" } }\n    : comp2Props;\n\n  const exampleOutput = [\n    JSON.stringify({ op: \"add\", path: \"/root\", value: \"main\" }),\n    JSON.stringify({\n      op: \"add\",\n      path: \"/elements/main\",\n      value: {\n        type: comp1,\n        props: comp1Props,\n        children: [\"child-1\", \"list\"],\n      },\n    }),\n    JSON.stringify({\n      op: \"add\",\n      path: \"/elements/child-1\",\n      value: { type: comp2, props: comp2Props, children: [] },\n    }),\n    JSON.stringify({\n      op: \"add\",\n      path: \"/elements/list\",\n      value: {\n        type: comp1,\n        props: comp1Props,\n        repeat: { statePath: \"/items\", key: \"id\" },\n        children: [\"item\"],\n      },\n    }),\n    JSON.stringify({\n      op: \"add\",\n      path: \"/elements/item\",\n      value: { type: comp2, props: dynamicProps, children: [] },\n    }),\n    JSON.stringify({ op: \"add\", path: \"/state/items\", value: [] }),\n    JSON.stringify({\n      op: \"add\",\n      path: \"/state/items/0\",\n      value: { id: \"1\", title: \"First Item\" },\n    }),\n    JSON.stringify({\n      op: \"add\",\n      path: \"/state/items/1\",\n      value: { id: \"2\", title: \"Second Item\" },\n    }),\n  ].join(\"\\n\");\n\n  lines.push(`${exampleOutput}\n\nNote: state patches appear right after the elements that use them, so the UI fills in as it streams. ONLY use component types from the AVAILABLE COMPONENTS list below.`);\n  lines.push(\"\");\n\n  // Initial state section\n  lines.push(\"INITIAL STATE:\");\n  lines.push(\n    \"Specs include a /state field to seed the state model. Components with { $bindState } or { $bindItem } read from and write to this state, and $state expressions read from it.\",\n  );\n  lines.push(\n    \"CRITICAL: You MUST include state patches whenever your UI displays data via $state, $bindState, $bindItem, $item, or $index expressions, or uses repeat to iterate over arrays. Without state, these references resolve to nothing and repeat lists render zero items.\",\n  );\n  lines.push(\n    \"Output state patches right after the elements that reference them, so the UI fills in progressively as it streams.\",\n  );\n  lines.push(\n    \"Stream state progressively - output one patch per array item instead of one giant blob:\",\n  );\n  lines.push(\n    '  For arrays: {\"op\":\"add\",\"path\":\"/state/posts/0\",\"value\":{\"id\":\"1\",\"title\":\"First Post\",...}} then /state/posts/1, /state/posts/2, etc.',\n  );\n  lines.push(\n    '  For scalars: {\"op\":\"add\",\"path\":\"/state/newTodoText\",\"value\":\"\"}',\n  );\n  lines.push(\n    '  Initialize the array first if needed: {\"op\":\"add\",\"path\":\"/state/posts\",\"value\":[]}',\n  );\n  lines.push(\n    'When content comes from the state model, use { \"$state\": \"/some/path\" } dynamic props to display it instead of hardcoding the same value in both state and props. The state model is the single source of truth.',\n  );\n  lines.push(\n    \"Include realistic sample data in state. For blogs: 3-4 posts with titles, excerpts, authors, dates. For product lists: 3-5 items with names, prices, descriptions. Never leave arrays empty.\",\n  );\n  lines.push(\"\");\n  lines.push(\"DYNAMIC LISTS (repeat field):\");\n  lines.push(\n    'Any element can have a top-level \"repeat\" field to render its children once per item in a state array: { \"repeat\": { \"statePath\": \"/arrayPath\", \"key\": \"id\" } }.',\n  );\n  lines.push(\n    'The element itself renders once (as the container), and its children are expanded once per array item. \"statePath\" is the state array path. \"key\" is an optional field name on each item for stable React keys.',\n  );\n  lines.push(\n    `Example: ${JSON.stringify({ type: comp1, props: comp1Props, repeat: { statePath: \"/todos\", key: \"id\" }, children: [\"todo-item\"] })}`,\n  );\n  lines.push(\n    'Inside children of a repeated element, use { \"$item\": \"field\" } to read a field from the current item, and { \"$index\": true } to get the current array index. For two-way binding to an item field use { \"$bindItem\": \"completed\" } on the appropriate prop.',\n  );\n  lines.push(\n    \"ALWAYS use the repeat field for lists backed by state arrays. NEVER hardcode individual elements for each array item.\",\n  );\n  lines.push(\n    'IMPORTANT: \"repeat\" is a top-level field on the element (sibling of type/props/children), NOT inside props.',\n  );\n  lines.push(\"\");\n  lines.push(\"ARRAY STATE ACTIONS:\");\n  lines.push(\n    'Use action \"pushState\" to append items to arrays. Params: { statePath: \"/arrayPath\", value: { ...item }, clearStatePath: \"/inputPath\" }.',\n  );\n  lines.push(\n    'Values inside pushState can contain { \"$state\": \"/statePath\" } references to read current state (e.g. the text from an input field).',\n  );\n  lines.push(\n    'Use \"$id\" inside a pushState value to auto-generate a unique ID.',\n  );\n  lines.push(\n    'Example: on: { \"press\": { \"action\": \"pushState\", \"params\": { \"statePath\": \"/todos\", \"value\": { \"id\": \"$id\", \"title\": { \"$state\": \"/newTodoText\" }, \"completed\": false }, \"clearStatePath\": \"/newTodoText\" } } }',\n  );\n  lines.push(\n    'Use action \"removeState\" to remove items from arrays by index. Params: { statePath: \"/arrayPath\", index: N }. Inside a repeated element\\'s children, use { \"$index\": true } for the current item index. Action params support the same expressions as props: { \"$item\": \"field\" } resolves to the absolute state path, { \"$index\": true } resolves to the index number, and { \"$state\": \"/path\" } reads a value from state.',\n  );\n  lines.push(\n    \"For lists where users can add/remove items (todos, carts, etc.), use pushState and removeState instead of hardcoding with setState.\",\n  );\n  lines.push(\"\");\n  lines.push(\n    'IMPORTANT: State paths use RFC 6901 JSON Pointer syntax (e.g. \"/todos/0/title\"). Do NOT use JavaScript-style dot notation (e.g. \"/todos.length\" is WRONG). To generate unique IDs for new items, use \"$id\" instead of trying to read array length.',\n  );\n  lines.push(\"\");\n\n  // Components section — reuse the typed reference from example generation\n  const components = allComponents;\n\n  if (components) {\n    lines.push(`AVAILABLE COMPONENTS (${catalog.componentNames.length}):`);\n    lines.push(\"\");\n\n    for (const [name, def] of Object.entries(components)) {\n      const propsStr = def.props ? formatZodType(def.props) : \"{}\";\n      const hasChildren = def.slots && def.slots.length > 0;\n      const childrenStr = hasChildren ? \" [accepts children]\" : \"\";\n      const eventsStr =\n        def.events && def.events.length > 0\n          ? ` [events: ${def.events.join(\", \")}]`\n          : \"\";\n      const descStr = def.description ? ` - ${def.description}` : \"\";\n      lines.push(`- ${name}: ${propsStr}${descStr}${childrenStr}${eventsStr}`);\n    }\n    lines.push(\"\");\n  }\n\n  // Actions section\n  const actions = (catalog.data as Record<string, unknown>).actions as\n    | Record<string, { params?: z.ZodType; description?: string }>\n    | undefined;\n\n  if (actions && catalog.actionNames.length > 0) {\n    lines.push(\"AVAILABLE ACTIONS:\");\n    lines.push(\"\");\n    for (const [name, def] of Object.entries(actions)) {\n      lines.push(`- ${name}${def.description ? `: ${def.description}` : \"\"}`);\n    }\n    lines.push(\"\");\n  }\n\n  // Events section\n  lines.push(\"EVENTS (the `on` field):\");\n  lines.push(\n    \"Elements can have an optional `on` field to bind events to actions. The `on` field is a top-level field on the element (sibling of type/props/children), NOT inside props.\",\n  );\n  lines.push(\n    'Each key in `on` is an event name (from the component\\'s supported events), and the value is an action binding: `{ \"action\": \"<actionName>\", \"params\": { ... } }`.',\n  );\n  lines.push(\"\");\n  lines.push(\"Example:\");\n  lines.push(\n    `  ${JSON.stringify({ type: comp1, props: comp1Props, on: { press: { action: \"setState\", params: { statePath: \"/saved\", value: true } } }, children: [] })}`,\n  );\n  lines.push(\"\");\n  lines.push(\n    'Action params can use dynamic references to read from state: { \"$state\": \"/statePath\" }.',\n  );\n  lines.push(\n    \"IMPORTANT: Do NOT put action/actionParams inside props. Always use the `on` field for event bindings.\",\n  );\n  lines.push(\"\");\n\n  // Visibility conditions\n  lines.push(\"VISIBILITY CONDITIONS:\");\n  lines.push(\n    \"Elements can have an optional `visible` field to conditionally show/hide based on state. IMPORTANT: `visible` is a top-level field on the element object (sibling of type/props/children), NOT inside props.\",\n  );\n  lines.push(\n    `Correct: ${JSON.stringify({ type: comp1, props: comp1Props, visible: { $state: \"/activeTab\", eq: \"home\" }, children: [\"...\"] })}`,\n  );\n  lines.push(\n    '- `{ \"$state\": \"/path\" }` - visible when state at path is truthy',\n  );\n  lines.push(\n    '- `{ \"$state\": \"/path\", \"not\": true }` - visible when state at path is falsy',\n  );\n  lines.push(\n    '- `{ \"$state\": \"/path\", \"eq\": \"value\" }` - visible when state equals value',\n  );\n  lines.push(\n    '- `{ \"$state\": \"/path\", \"neq\": \"value\" }` - visible when state does not equal value',\n  );\n  lines.push(\n    '- `{ \"$state\": \"/path\", \"gt\": N }` / `gte` / `lt` / `lte` - numeric comparisons',\n  );\n  lines.push(\n    \"- Use ONE operator per condition (eq, neq, gt, gte, lt, lte). Do not combine multiple operators.\",\n  );\n  lines.push('- Any condition can add `\"not\": true` to invert its result');\n  lines.push(\n    \"- `[condition, condition]` - all conditions must be true (implicit AND)\",\n  );\n  lines.push(\n    '- `{ \"$and\": [condition, condition] }` - explicit AND (use when nesting inside $or)',\n  );\n  lines.push(\n    '- `{ \"$or\": [condition, condition] }` - at least one must be true (OR)',\n  );\n  lines.push(\"- `true` / `false` - always visible/hidden\");\n  lines.push(\"\");\n  lines.push(\n    \"Use a component with on.press bound to setState to update state and drive visibility.\",\n  );\n  lines.push(\n    `Example: A ${comp1} with on: { \"press\": { \"action\": \"setState\", \"params\": { \"statePath\": \"/activeTab\", \"value\": \"home\" } } } sets state, then a container with visible: { \"$state\": \"/activeTab\", \"eq\": \"home\" } shows only when that tab is active.`,\n  );\n  lines.push(\"\");\n  lines.push(\n    'For tab patterns where the first/default tab should be visible when no tab is selected yet, use $or to handle both cases: visible: { \"$or\": [{ \"$state\": \"/activeTab\", \"eq\": \"home\" }, { \"$state\": \"/activeTab\", \"not\": true }] }. This ensures the first tab is visible both when explicitly selected AND when /activeTab is not yet set.',\n  );\n  lines.push(\"\");\n\n  // Dynamic prop expressions\n  lines.push(\"DYNAMIC PROPS:\");\n  lines.push(\n    \"Any prop value can be a dynamic expression that resolves based on state. Three forms are supported:\",\n  );\n  lines.push(\"\");\n  lines.push(\n    '1. Read-only state: `{ \"$state\": \"/statePath\" }` - resolves to the value at that state path (one-way read).',\n  );\n  lines.push(\n    '   Example: `\"color\": { \"$state\": \"/theme/primary\" }` reads the color from state.',\n  );\n  lines.push(\"\");\n  lines.push(\n    '2. Two-way binding: `{ \"$bindState\": \"/statePath\" }` - resolves to the value at the state path AND enables write-back. Use on form input props (value, checked, pressed, etc.).',\n  );\n  lines.push(\n    '   Example: `\"value\": { \"$bindState\": \"/form/email\" }` binds the input value to /form/email.',\n  );\n  lines.push(\n    '   Inside repeat scopes: `\"checked\": { \"$bindItem\": \"completed\" }` binds to the current item\\'s completed field.',\n  );\n  lines.push(\"\");\n  lines.push(\n    '3. Conditional: `{ \"$cond\": <condition>, \"$then\": <value>, \"$else\": <value> }` - evaluates the condition (same syntax as visibility conditions) and picks the matching value.',\n  );\n  lines.push(\n    '   Example: `\"color\": { \"$cond\": { \"$state\": \"/activeTab\", \"eq\": \"home\" }, \"$then\": \"#007AFF\", \"$else\": \"#8E8E93\" }`',\n  );\n  lines.push(\"\");\n  lines.push(\n    \"Use $bindState for form inputs (text fields, checkboxes, selects, sliders, etc.) and $state for read-only data display. Inside repeat scopes, use $bindItem for form inputs bound to the current item. Use dynamic props instead of duplicating elements with opposing visible conditions when only prop values differ.\",\n  );\n  lines.push(\"\");\n\n  // Validation section — only emit when at least one component has a `checks` prop\n  const hasChecksComponents = allComponents\n    ? Object.entries(allComponents).some(([, def]) => {\n        if (!def.props) return false;\n        const formatted = formatZodType(def.props);\n        return formatted.includes(\"checks\");\n      })\n    : false;\n\n  if (hasChecksComponents) {\n    lines.push(\"VALIDATION:\");\n    lines.push(\n      \"Form components that accept a `checks` prop support client-side validation.\",\n    );\n    lines.push(\n      'Each check is an object: { \"type\": \"<name>\", \"message\": \"...\", \"args\": { ... } }',\n    );\n    lines.push(\"\");\n    lines.push(\"Built-in validation types:\");\n    lines.push(\"  - required — value must be non-empty\");\n    lines.push(\"  - email — valid email format\");\n    lines.push('  - minLength — minimum string length (args: { \"min\": N })');\n    lines.push('  - maxLength — maximum string length (args: { \"max\": N })');\n    lines.push('  - pattern — match a regex (args: { \"pattern\": \"regex\" })');\n    lines.push('  - min — minimum numeric value (args: { \"min\": N })');\n    lines.push('  - max — maximum numeric value (args: { \"max\": N })');\n    lines.push(\"  - numeric — value must be a number\");\n    lines.push(\"  - url — valid URL format\");\n    lines.push(\n      '  - matches — must equal another field (args: { \"other\": \"value\" })',\n    );\n    lines.push(\"\");\n    lines.push(\"Example:\");\n    lines.push(\n      '  \"checks\": [{ \"type\": \"required\", \"message\": \"Email is required\" }, { \"type\": \"email\", \"message\": \"Invalid email\" }]',\n    );\n    lines.push(\"\");\n    lines.push(\n      \"IMPORTANT: When using checks, the component must also have a { $bindState } or { $bindItem } on its value/checked prop for two-way binding.\",\n    );\n    lines.push(\n      \"Always include validation checks on form inputs for a good user experience (e.g. required, email, minLength).\",\n    );\n    lines.push(\"\");\n  }\n\n  // Rules\n  lines.push(\"RULES:\");\n  const baseRules =\n    mode === \"chat\"\n      ? [\n          \"When generating UI, wrap all JSONL patches in a ```spec code fence - one JSON object per line inside the fence\",\n          \"Write a brief conversational response before any JSONL output\",\n          'First set root: {\"op\":\"add\",\"path\":\"/root\",\"value\":\"<root-key>\"}',\n          'Then add each element: {\"op\":\"add\",\"path\":\"/elements/<key>\",\"value\":{...}}',\n          \"Output /state patches right after the elements that use them, one per array item for progressive loading. REQUIRED whenever using $state, $bindState, $bindItem, $item, $index, or repeat.\",\n          \"ONLY use components listed above\",\n          \"Each element value needs: type, props, children (array of child keys)\",\n          \"Use unique keys for the element map entries (e.g., 'header', 'metric-1', 'chart-revenue')\",\n        ]\n      : [\n          \"Output ONLY JSONL patches - one JSON object per line, no markdown, no code fences\",\n          'First set root: {\"op\":\"add\",\"path\":\"/root\",\"value\":\"<root-key>\"}',\n          'Then add each element: {\"op\":\"add\",\"path\":\"/elements/<key>\",\"value\":{...}}',\n          \"Output /state patches right after the elements that use them, one per array item for progressive loading. REQUIRED whenever using $state, $bindState, $bindItem, $item, $index, or repeat.\",\n          \"ONLY use components listed above\",\n          \"Each element value needs: type, props, children (array of child keys)\",\n          \"Use unique keys for the element map entries (e.g., 'header', 'metric-1', 'chart-revenue')\",\n        ];\n  const schemaRules = catalog.schema.defaultRules ?? [];\n  const allRules = [...baseRules, ...schemaRules, ...customRules];\n  allRules.forEach((rule, i) => {\n    lines.push(`${i + 1}. ${rule}`);\n  });\n\n  return lines.join(\"\\n\");\n}\n\n// =============================================================================\n// Example Value Generation from Zod Schemas\n// =============================================================================\n\n/**\n * Component definition shape as it appears in catalog data\n */\ninterface CatalogComponentDef {\n  props?: z.ZodType;\n  description?: string;\n  slots?: string[];\n  events?: string[];\n  example?: Record<string, unknown>;\n}\n\n/**\n * Get example props for a catalog component.\n * Uses the explicit `example` field if provided, otherwise generates from Zod schema.\n */\nfunction getExampleProps(def: CatalogComponentDef): Record<string, unknown> {\n  if (def.example && Object.keys(def.example).length > 0) {\n    return def.example;\n  }\n  if (def.props) {\n    return generateExamplePropsFromZod(def.props);\n  }\n  return {};\n}\n\n/**\n * Generate example prop values from a Zod object schema.\n * Only includes required fields to keep examples concise.\n */\nfunction generateExamplePropsFromZod(\n  schema: z.ZodType,\n): Record<string, unknown> {\n  if (!schema || !schema._def) return {};\n  const def = schema._def as unknown as Record<string, unknown>;\n  const typeName = getZodTypeName(schema);\n\n  if (typeName !== \"ZodObject\" && typeName !== \"object\") return {};\n\n  const shape =\n    typeof def.shape === \"function\"\n      ? (def.shape as () => Record<string, z.ZodType>)()\n      : (def.shape as Record<string, z.ZodType>);\n  if (!shape) return {};\n\n  const result: Record<string, unknown> = {};\n  for (const [key, value] of Object.entries(shape)) {\n    const innerTypeName = getZodTypeName(value);\n    // Skip optional props to keep examples concise\n    if (\n      innerTypeName === \"ZodOptional\" ||\n      innerTypeName === \"optional\" ||\n      innerTypeName === \"ZodNullable\" ||\n      innerTypeName === \"nullable\"\n    ) {\n      continue;\n    }\n    result[key] = generateExampleValue(value);\n  }\n  return result;\n}\n\n/**\n * Generate a single example value from a Zod type.\n */\nfunction generateExampleValue(schema: z.ZodType): unknown {\n  if (!schema || !schema._def) return \"...\";\n  const def = schema._def as unknown as Record<string, unknown>;\n  const typeName = getZodTypeName(schema);\n\n  switch (typeName) {\n    case \"ZodString\":\n    case \"string\":\n      return \"example\";\n    case \"ZodNumber\":\n    case \"number\":\n      return 0;\n    case \"ZodBoolean\":\n    case \"boolean\":\n      return true;\n    case \"ZodLiteral\":\n    case \"literal\":\n      return def.value;\n    case \"ZodEnum\":\n    case \"enum\": {\n      if (Array.isArray(def.values) && def.values.length > 0)\n        return def.values[0];\n      if (def.entries && typeof def.entries === \"object\") {\n        const values = Object.values(def.entries as Record<string, string>);\n        return values.length > 0 ? values[0] : \"example\";\n      }\n      return \"example\";\n    }\n    case \"ZodOptional\":\n    case \"optional\":\n    case \"ZodNullable\":\n    case \"nullable\":\n    case \"ZodDefault\":\n    case \"default\": {\n      const inner = (def.innerType as z.ZodType) ?? (def.wrapped as z.ZodType);\n      return inner ? generateExampleValue(inner) : null;\n    }\n    case \"ZodArray\":\n    case \"array\":\n      return [];\n    case \"ZodObject\":\n    case \"object\":\n      return generateExamplePropsFromZod(schema);\n    case \"ZodUnion\":\n    case \"union\": {\n      const options = def.options as z.ZodType[] | undefined;\n      return options && options.length > 0\n        ? generateExampleValue(options[0]!)\n        : \"...\";\n    }\n    default:\n      return \"...\";\n  }\n}\n\n/**\n * Find the name of the first required string prop in a Zod object schema.\n * Used to demonstrate $state dynamic bindings in examples.\n */\nfunction findFirstStringProp(schema?: z.ZodType): string | null {\n  if (!schema || !schema._def) return null;\n  const def = schema._def as unknown as Record<string, unknown>;\n  const typeName = getZodTypeName(schema);\n\n  if (typeName !== \"ZodObject\" && typeName !== \"object\") return null;\n\n  const shape =\n    typeof def.shape === \"function\"\n      ? (def.shape as () => Record<string, z.ZodType>)()\n      : (def.shape as Record<string, z.ZodType>);\n  if (!shape) return null;\n\n  for (const [key, value] of Object.entries(shape)) {\n    const innerTypeName = getZodTypeName(value);\n    // Skip optional props\n    if (\n      innerTypeName === \"ZodOptional\" ||\n      innerTypeName === \"optional\" ||\n      innerTypeName === \"ZodNullable\" ||\n      innerTypeName === \"nullable\"\n    ) {\n      continue;\n    }\n    // Unwrap to check the actual type\n    if (innerTypeName === \"ZodString\" || innerTypeName === \"string\") {\n      return key;\n    }\n  }\n  return null;\n}\n\n// =============================================================================\n// Zod Introspection Helpers\n// =============================================================================\n\n/**\n * Get Zod type name from schema (handles different Zod versions)\n */\nfunction getZodTypeName(schema: z.ZodType): string {\n  if (!schema || !schema._def) return \"\";\n  const def = schema._def as unknown as Record<string, unknown>;\n  // Zod 4+ uses _def.type, older versions use _def.typeName\n  return (def.typeName as string) ?? (def.type as string) ?? \"\";\n}\n\n/**\n * Format a Zod type into a human-readable string\n */\nfunction formatZodType(schema: z.ZodType): string {\n  if (!schema || !schema._def) return \"unknown\";\n  const def = schema._def as unknown as Record<string, unknown>;\n  const typeName = getZodTypeName(schema);\n\n  switch (typeName) {\n    case \"ZodString\":\n    case \"string\":\n      return \"string\";\n    case \"ZodNumber\":\n    case \"number\":\n      return \"number\";\n    case \"ZodBoolean\":\n    case \"boolean\":\n      return \"boolean\";\n    case \"ZodLiteral\":\n    case \"literal\":\n      return JSON.stringify(def.value);\n    case \"ZodEnum\":\n    case \"enum\": {\n      // Zod 3 uses values array, Zod 4 uses entries object\n      let values: string[];\n      if (Array.isArray(def.values)) {\n        values = def.values as string[];\n      } else if (def.entries && typeof def.entries === \"object\") {\n        values = Object.values(def.entries as Record<string, string>);\n      } else {\n        return \"enum\";\n      }\n      return values.map((v) => `\"${v}\"`).join(\" | \");\n    }\n    case \"ZodArray\":\n    case \"array\": {\n      const inner = (def.type as z.ZodType) ?? (def.element as z.ZodType);\n      return inner ? `Array<${formatZodType(inner)}>` : \"Array<unknown>\";\n    }\n    case \"ZodObject\":\n    case \"object\": {\n      // Shape can be a function (Zod 3) or direct object (Zod 4)\n      const shape =\n        typeof def.shape === \"function\"\n          ? (def.shape as () => Record<string, z.ZodType>)()\n          : (def.shape as Record<string, z.ZodType>);\n      if (!shape) return \"object\";\n      const props = Object.entries(shape)\n        .map(([key, value]) => {\n          const innerTypeName = getZodTypeName(value);\n          const isOptional =\n            innerTypeName === \"ZodOptional\" ||\n            innerTypeName === \"ZodNullable\" ||\n            innerTypeName === \"optional\" ||\n            innerTypeName === \"nullable\";\n          return `${key}${isOptional ? \"?\" : \"\"}: ${formatZodType(value)}`;\n        })\n        .join(\", \");\n      return `{ ${props} }`;\n    }\n    case \"ZodOptional\":\n    case \"optional\":\n    case \"ZodNullable\":\n    case \"nullable\": {\n      const inner = (def.innerType as z.ZodType) ?? (def.wrapped as z.ZodType);\n      return inner ? formatZodType(inner) : \"unknown\";\n    }\n    case \"ZodUnion\":\n    case \"union\": {\n      const options = def.options as z.ZodType[] | undefined;\n      return options\n        ? options.map((opt) => formatZodType(opt)).join(\" | \")\n        : \"unknown\";\n    }\n    default:\n      return \"unknown\";\n  }\n}\n\n/**\n * Convert Zod schema to JSON Schema\n */\nfunction zodToJsonSchema(schema: z.ZodType): object {\n  // Simplified JSON Schema conversion\n  const def = schema._def as unknown as Record<string, unknown>;\n  const typeName = (def.typeName as string) ?? \"\";\n\n  switch (typeName) {\n    case \"ZodString\":\n      return { type: \"string\" };\n    case \"ZodNumber\":\n      return { type: \"number\" };\n    case \"ZodBoolean\":\n      return { type: \"boolean\" };\n    case \"ZodLiteral\":\n      return { const: def.value };\n    case \"ZodEnum\":\n      return { enum: def.values };\n    case \"ZodArray\": {\n      const inner = def.type as z.ZodType | undefined;\n      return {\n        type: \"array\",\n        items: inner ? zodToJsonSchema(inner) : {},\n      };\n    }\n    case \"ZodObject\": {\n      const shape = (def.shape as () => Record<string, z.ZodType>)?.();\n      if (!shape) return { type: \"object\" };\n      const properties: Record<string, object> = {};\n      const required: string[] = [];\n      for (const [key, value] of Object.entries(shape)) {\n        properties[key] = zodToJsonSchema(value);\n        const innerDef = value._def as unknown as Record<string, unknown>;\n        if (\n          innerDef.typeName !== \"ZodOptional\" &&\n          innerDef.typeName !== \"ZodNullable\"\n        ) {\n          required.push(key);\n        }\n      }\n      return {\n        type: \"object\",\n        properties,\n        required: required.length > 0 ? required : undefined,\n        additionalProperties: false,\n      };\n    }\n    case \"ZodRecord\": {\n      const valueType = def.valueType as z.ZodType | undefined;\n      return {\n        type: \"object\",\n        additionalProperties: valueType ? zodToJsonSchema(valueType) : true,\n      };\n    }\n    case \"ZodOptional\":\n    case \"ZodNullable\": {\n      const inner = def.innerType as z.ZodType | undefined;\n      return inner ? zodToJsonSchema(inner) : {};\n    }\n    case \"ZodUnion\": {\n      const options = def.options as z.ZodType[] | undefined;\n      return options ? { anyOf: options.map(zodToJsonSchema) } : {};\n    }\n    case \"ZodAny\":\n      return {};\n    default:\n      return {};\n  }\n}\n\n/**\n * Shorthand: Define a catalog directly from a schema\n */\nexport function defineCatalog<\n  TDef extends SchemaDefinition,\n  TCatalog extends InferCatalogInput<TDef[\"catalog\"]>,\n>(schema: Schema<TDef>, catalog: TCatalog): Catalog<TDef, TCatalog> {\n  return schema.createCatalog(catalog);\n}\n","import type { Spec } from \"./types\";\n\n/**\n * Options for building a user prompt.\n */\nexport interface UserPromptOptions {\n  /** The user's text prompt */\n  prompt: string;\n  /** Existing spec to refine (triggers patch-only mode) */\n  currentSpec?: Spec | null;\n  /** Runtime state context to include */\n  state?: Record<string, unknown> | null;\n  /** Maximum length for the user's text prompt (applied before wrapping) */\n  maxPromptLength?: number;\n}\n\n/**\n * Check whether a spec is non-empty (has a root and at least one element).\n */\nfunction isNonEmptySpec(spec: unknown): spec is Spec {\n  if (!spec || typeof spec !== \"object\") return false;\n  const s = spec as Record<string, unknown>;\n  return (\n    typeof s.root === \"string\" &&\n    typeof s.elements === \"object\" &&\n    s.elements !== null &&\n    Object.keys(s.elements as object).length > 0\n  );\n}\n\nconst PATCH_INSTRUCTIONS = `IMPORTANT: The current UI is already loaded. Output ONLY the patches needed to make the requested change:\n- To add a new element: {\"op\":\"add\",\"path\":\"/elements/new-key\",\"value\":{...}}\n- To modify an existing element: {\"op\":\"replace\",\"path\":\"/elements/existing-key\",\"value\":{...}}\n- To remove an element: {\"op\":\"remove\",\"path\":\"/elements/old-key\"}\n- To update the root: {\"op\":\"replace\",\"path\":\"/root\",\"value\":\"new-root-key\"}\n- To add children: update the parent element with new children array\n\nDO NOT output patches for elements that don't need to change. Only output what's necessary for the requested modification.`;\n\n/**\n * Build a user prompt for AI generation.\n *\n * Handles common patterns that every consuming app needs:\n * - Truncating the user's prompt to a max length\n * - Including the current spec for refinement (patch-only mode)\n * - Including runtime state context\n *\n * @example\n * ```ts\n * // Fresh generation\n * buildUserPrompt({ prompt: \"create a todo app\" })\n *\n * // Refinement with existing spec\n * buildUserPrompt({ prompt: \"add a dark mode toggle\", currentSpec: spec })\n *\n * // With state context\n * buildUserPrompt({ prompt: \"show my data\", state: { todos: [] } })\n * ```\n */\nexport function buildUserPrompt(options: UserPromptOptions): string {\n  const { prompt, currentSpec, state, maxPromptLength } = options;\n\n  // Sanitize and optionally truncate the user's text\n  let userText = String(prompt || \"\");\n  if (maxPromptLength !== undefined && maxPromptLength > 0) {\n    userText = userText.slice(0, maxPromptLength);\n  }\n\n  // --- Refinement mode: currentSpec is provided ---\n  if (isNonEmptySpec(currentSpec)) {\n    const parts: string[] = [];\n\n    parts.push(\n      `CURRENT UI STATE (already loaded, DO NOT recreate existing elements):`,\n    );\n    parts.push(JSON.stringify(currentSpec, null, 2));\n    parts.push(\"\");\n    parts.push(`USER REQUEST: ${userText}`);\n\n    // Append state context if provided\n    if (state && Object.keys(state).length > 0) {\n      parts.push(\"\");\n      parts.push(`AVAILABLE STATE:\\n${JSON.stringify(state, null, 2)}`);\n    }\n\n    parts.push(\"\");\n    parts.push(PATCH_INSTRUCTIONS);\n\n    return parts.join(\"\\n\");\n  }\n\n  // --- Fresh generation mode ---\n  const parts: string[] = [userText];\n\n  if (state && Object.keys(state).length > 0) {\n    parts.push(`\\nAVAILABLE STATE:\\n${JSON.stringify(state, null, 2)}`);\n  }\n\n  parts.push(\n    `\\nRemember: Output /root first, then interleave /elements and /state patches so the UI fills in progressively as it streams. Output each state patch right after the elements that use it, one per array item.`,\n  );\n\n  return parts.join(\"\\n\");\n}\n"],"mappings":"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","names":["patch","import_zod","import_zod","action","executeAction","import_zod","check","import_zod","parts"]}